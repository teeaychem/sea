#+STARTUP: Overview
#+PROPERTY: header-args :noweb eval :results output
#+TITLE: K & R Exercises

* chapter 1

** 1-1

#+BEGIN_SRC C
  #include <stdio.h>

  int main()
  {
    printf("Hello, world!\n");
  }
#+END_SRC

#+RESULTS:

** 1-2

~\o~ is related to ~\0~?

** 1-3

Included in Ex. 4, though formatting other than a heading.

** 1-4

Inluced in Ex. 5

** 1-5

Straightfoward, with a few additions for testing whether constants are limited to ints (no).

#+BEGIN_SRC C
#include <stdio.h>

/*
  make a Fahrenheit-Celcuis table
 */

# define LOWER 0
# define FUPPER 212
# define FSTEP 20
# define CUPPER 100
# define CSTEP 7.532
/* No typing with symbolic constants… */

# define CLOSING_MSG "Goodbye!\n"
/*
  What's stored is determined.
  But, what about interpreting the bits?
 */


int main() {
  /* int fahr, celsius; */
  float celsius, fahr;

  printf("To begin, some fahrenheit\n");
  celsius = 0;

  /*
    No restriction on test condition. But need everything initialised.
    So, test before first instance, allowing to skip entirely.
  */
  for (fahr = FUPPER; celsius >= LOWER; fahr = fahr - FSTEP) {

    celsius = (5 * (fahr - 32)) / 9.0;
    printf("%6.2f < c ~ f > %6.2f\n", celsius, fahr);
  }

  printf("And now, for some celcuis\n");

  for (celsius = CUPPER; celsius >= LOWER; celsius = celsius - CSTEP) {
    fahr = ((celsius * 9) / 5.0) + 32;
    printf("%6.2f < c ~ f > %6.2f\n", celsius, fahr);
  }

  printf(CLOSING_MSG);
}

#+END_SRC

#+RESULTS:
#+begin_example
To begin, some fahrenheit
100.00 < c ~ f > 212.00
 88.89 < c ~ f > 192.00
 77.78 < c ~ f > 172.00
 66.67 < c ~ f > 152.00
 55.56 < c ~ f > 132.00
 44.44 < c ~ f > 112.00
 33.33 < c ~ f >  92.00
 22.22 < c ~ f >  72.00
 11.11 < c ~ f >  52.00
  0.00 < c ~ f >  32.00
-11.11 < c ~ f >  12.00
And now, for some celcuis
100.00 < c ~ f > 212.00
 92.47 < c ~ f > 198.44
 84.94 < c ~ f > 184.88
 77.40 < c ~ f > 171.33
 69.87 < c ~ f > 157.77
 62.34 < c ~ f > 144.21
 54.81 < c ~ f > 130.65
 47.28 < c ~ f > 117.10
 39.74 < c ~ f > 103.54
 32.21 < c ~ f >  89.98
 24.68 < c ~ f >  76.42
 17.15 < c ~ f >  62.87
  9.62 < c ~ f >  49.31
  2.08 < c ~ f >  35.75
Goodbye!
#+end_example

** 1-6

The parentheses aren't really required.
And, it's fine to set ~val~ as either ~char~ or ~int~ with ~%d~.
Things get messy with ~%s~.

#+BEGIN_SRC C
  #include <stdio.h>

  int val;
  char c;

  int main() {
    val = ((c = getchar()) != EOF);
    printf("%d", val);
  }
#+END_SRC

** 1-7

Extends 6 and prints things a little more elegantly.

#+BEGIN_SRC C
  #include <stdio.h>

  int val;
  char c;

  int main()
  {
   val = ((c = getchar()) != EOF);

   printf("You entered %c\n" , c);
   printf("Testing whether %c is not equal to EOF returns %d\n", c, val);

   printf("Also, if we try to print EOF the result is:\n");
   printf("%c - with c\n", EOF);
   printf("%d - with d\n", EOF);
   printf("Goodbye!\n", EOF);
   }
#+END_SRC

Sample output is

#+BEGIN_SRC C
  t
  You entered t
  Testing whether t is not equal to EOF returns 1
  Also, if we try to print EOF the result is:
  � - with c
  -1 - with d
  Goodbye!
#+END_SRC

So, there's no associated character (go figure!) and EOF is neither truthy or falsey.

** 1-8

#+BEGIN_SRC C
  #include <stdio.h>

  int main() {

    long charCount;
    int lineCount, tabCount, blankCount;
    char c;

    charCount = 0;
    lineCount = 0;
    tabCount = 0;
    blankCount = 0;

    while ((c = getchar()) != EOF) {

      if (c == '\n') {
	++lineCount;
      }
      else if (c == ' ') {
	++blankCount;
      }
      else if (c == '\t') {
	++tabCount;
      }
      else {
	++charCount;
      }
    }

    printf("The text contained:\n");
    printf("%d lines\n", lineCount);
    printf("%d tabs\n", tabCount);
    printf("%d blank characters\n", blankCount);
    printf("%ld (non-blank) characters\n", charCount);
    printf("Goodbye!\n");
  }
#+END_SRC

As multiple things are testing for each run of the loop a ~for~ construction doesn't make sense here.
Could drop brackets around all the conditions.
Could do more to format the results.

** 1-9

A little messy.
Set up a counter for number of blank chars seen, print only when this is less than 1.
Not ideal if wish to do similar things with different chars, as each other check needs to rest.

#+BEGIN_SRC C
  #include <stdio.h>

  int main() {

    long charCount;
    int lineCount, tabCount, blankCount, previousBlank, blanksLost;
    char c;

    charCount = 0;
    lineCount = 0;
    tabCount = 0;
    blankCount = 0;
    previousBlank = 0;
    blanksLost = 0;

    while ((c = getchar()) != EOF) {

      if (c == ' ') {
	++blankCount;
	++previousBlank;
      }
      else {
	if (c == '\n') {
	  ++lineCount;
	}
	else if (c == '\t') {
	  ++tabCount;
	}
	else {
	  ++charCount;
	}
	if (previousBlank > 1) {
	  blanksLost = blanksLost + (previousBlank - 1);
	}
	previousBlank = 0;
      }

      if (previousBlank < 2) {
	putchar(c);
      }
    }

    printf("The text contained:\n");
    printf("%d lines\n", lineCount);
    printf("%d tabs\n", tabCount);
    printf("%d blank characters (%d were lost)\n", blankCount, blanksLost);
    printf("%ld (non-blank) characters\n", charCount);
    printf("Goodbye!\n");
  }
#+END_SRC

** 1-10

Getting even more messy.
If a replacement is needed, signal to first output ~\~ and update ~c~ to relevant char.
Note, special case for newline, as to make things look nice, we want to both display ~\n~ and also still print a newline.

#+BEGIN_SRC C
  #include <stdio.h>

int main() {

  long charCount;
  int lineCount, tabCount, blankCount, previousBlank, blanksLost, replacement;
  char c;

  charCount = 0;
  lineCount = 0;
  tabCount = 0;
  blankCount = 0;
  previousBlank = 0;
  blanksLost = 0;
  replacement = 0;

  while ((c = getchar()) != EOF) {

    replacement = 0;

    if (c == ' ') {
      ++blankCount;
      ++previousBlank;
    }
    else {
      if (c == '\n') {
	c = 'n';
	++lineCount;
	replacement = 2; /* special case to flag newline still needed */
      }
      if (c == '\t') {
	c = 't';
	++tabCount;
	replacement = 1;
      }
      if (c == '\\') {
	replacement = 1;
      }

      if (replacement > 0) {
	putchar('\\');
      }
      else {
	++charCount;
      }
      if (previousBlank > 1) {
	blanksLost = blanksLost + (previousBlank - 1);
      }
      previousBlank = 0;
    }

    if (previousBlank < 2) {
      putchar(c);
      if (replacement == 2) {
	putchar('\n');
      }
    }
  }

  printf("The text contained:\n");
  printf("%d lines\n", lineCount);
  printf("%d tabs\n", tabCount);
  printf("%d blank characters (%d were lost)\n", blankCount, blanksLost);
  printf("%ld (non-blank) characters\n", charCount);
  printf("Goodbye!\n");
}
#+END_SRC

Backspace is difficult.

Following the above, the case would be:

#+BEGIN_SRC C
  if (c == '\b') {
    c = 'b';
    replacement = 1;
  }
#+END_SRC

However, characters are only passed on after pressing enter.
So, there's no way to pass on a backspace.

Note, this has various effects, esp. with respect to when a newline is or isn't printed.

** 1-11

Test the word count program against some texts where the count is known.
In particular, texts which include a variety of characters, esp. special characters.

For example, what happens with numbers?

Should 21 be no words, one word ('21' or 'twenty-one'), or two words (twenty one)?

Similarly, what about (3/11)?

And, what happens with something like ^B (the backspace char)?

** 1-12

Moslty a modification of word counting in the text.
Just, without the counting, and the body of empty case involving a flag.

#+BEGIN_SRC C
#include <stdio.h>

#define IN 1
#define OUT 0

int main() {

  int c, state;
  state = OUT;

  while ((c = getchar()) != EOF) {
    if (c == ' ' || c == '\t') {
      if (state == IN) {
	putchar('\n');
	state = OUT;
      }
    } else {
      state = IN;
      putchar(c);
    }
  }
}
#+END_SRC

** 1-13

Histogram in vertical orientaion.

Sample output:

#+BEGIN_SRC C
  a a a
  bb bb
  ccc ccc ccc ccc ccc
  dddd
  eeeeee eeeeee
  fffffff
  ggggggggg ggggggggg ggggggggg

	 |
	 |
   |     |                 |
   |  |  |        |        |
   |  |  |  |     |  |     |
   1  2  3  4  5  6  7  8  9
#+END_SRC

For the histogram, figure out the maximum count, then work down to 0 printing a bar whenever the count for the number is within the scope.
This uses a lot of for loops, and some things could be tidied up a little.

A highly dodgy initial version of the program is preserved a revised version.

*** prog

Note, the maximum word length is specified, and array is initialised to this length, and we only add a count to the record when the word length falls within the maximum.
The size of arrays is fixed, and things go wrong is this is forgotten about.

#+BEGIN_SRC C
#include <stdio.h>

#define IN 1
#define OUT 0
#define MAX_WL 20

  int main() {

    int i, j, c, wc, state, top_wf, top_wl;

    wc = top_wf = top_wl = 0;
    int wl[MAX_WL];
    state = OUT;

    for (i = 0; i < MAX_WL; ++i) {
      wl[i] = 0;
    }

    while ((c = getchar()) != EOF) {
      if (c == ' ' || c == '\t' || c == '\n') {
	if (state == IN) {
	  state = OUT;
	  if (wc <= MAX_WL) {
	    ++wl[wc - 1]; /* no need to count 0 */
	  }
	  wc = 0;
	}
      } else {
	state = IN;
	++wc;
      }
    }

    /* figure out max word length could
       be done while building but assume
       fewer lengths than words
    */
    for (i = 0; i < MAX_WL; ++i) {
      if (wl[i] != 0) {
	top_wl = i + 1;
	if (wl[i] > top_wf) {
	  top_wf = wl[i];
	}
      }
    }

    /* make histogram.
       go from the max length down and print
       a bar if count exceeds current
    */
    for (i = top_wf; i >= 0; --i) {
      for (j = 0; j < top_wl; ++j) {
	if (wl[j] > i) {
	  printf("  |");
	} else {
	  printf("   ");
	}
      }
      printf("\n");
    }
    /* finish off with integer */
    for (j = 0; j < top_wl; ++j) {
      printf("%3d", j + 1);
    }
    printf("\n");
  }#+END_SRC

*** bad prog

Variables named like this aren't much better than magic numbers…

I'm not sure why I thought this worked as I don't to anything to suggest the length of wl has been updated.
All I do is continue to write past the space allocated to wl and hope things work out.

#+BEGIN_SRC C
  #include <stdio.h>

  #define IN 1
  #define OUT 0

  int main() {

    int i, j, c, wc, state, old_wl, new_wl, max_wl;

    wc = max_wl = old_wl = 0;
    new_wl = 2;
    int wl[new_wl];
    state = OUT;

    for (i = old_wl; i < new_wl; ++i) {
      wl[i] = 0;
    }

    while ((c = getchar()) != EOF) {
      if (c == ' ' || c == '\t' || c == '\n') {
	if (state == IN) {
	  state = OUT;

	  if (wc >= new_wl) { /* extend the array if needed */
	    old_wl = new_wl;
	    new_wl = wc;
	    for (i = old_wl; i < new_wl; ++i) {
	      wl[i] = 0;
	    }
	  }
	  ++wl[wc - 1];
	  wc = 0;
	}
      } else {
	state = IN;
	++wc;
      }
    }

    /* figure out max word length could
       be done while building but assume
       fewer lengths than words
    ,*/
    for (i = 0; i < new_wl; ++i) {
      if (wl[i] > max_wl) {
	max_wl = wl[i];
      }
    }

    /* make histogram.
       go from the max length down and print
       a bar if count exceeds current
    ,*/
    for (i = max_wl; i >= 0; --i) {
      for (j = 0; j < new_wl; ++j) {
	if (wl[j] > i) {
	  printf(" | ");
	} else {
	  printf("   ");
	}
      }
      printf("\n");
    }
    /* finish off with integer */
    for (j = 1; j <= new_wl; ++j) {
      printf(" %d ", j);
    }
    printf("\n");
  }
#+END_SRC

** 1-14

A little easier than counting words as character choices are known beforehand.
Here, lowercase alphabetic characters are counted.
Uppercase could be added by a an additional check and further offset to obtain lowercase value.

*** sample output

#+BEGIN_SRC C
   5                          |              |
   4  |                       |              |  |           |                 |
   3  |                       |     |        |  |           |                 |
   2  |        |  |     |     |     |     |  |  |           |                 |
   1  |        |  |     |     |     |     |  |  |        |  |                 |
   0  |        |  |  |  |  |  |     |     |  |  |  |     |  |  |        |     |  |
      a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z
#+END_SRC

*** prog


#+BEGIN_SRC C
  #include <stdio.h>

  int main() {

    int i, j, c, max_wl;

    max_wl = 0;

    int wl[26];

    for (i = 0; i < 26; ++i) {
      wl[i] = 0;
    }

    while ((c = getchar()) != EOF) {
      if (c >= 'a' && c <= 'z') {
	++wl[c - 'a'];
      }
    }

    for (i = 0; i < 26; ++i) {
      if (wl[i] > max_wl) {
	max_wl = wl[i];
      }
    }

    printf("\n");
    for (i = max_wl - 1; i >= 0; --i) {
      printf(" %3d ", i);
      for (j = 0; j < 26; ++j) {
	if (wl[j] > i) {
	  printf(" | ");
	} else {
	  printf("   ");
	}
      }
      printf("\n");
    }
    printf("     ");
    for (j = 0; j < 26; ++j) {
      printf(" %c ", j + 'a');
    }
    printf("\n");
    }
#+END_SRC

** 1-15

The toFahrenheit and toCelcius functions are simple.

printTable may need some revision.
On current understanding, pass functions by pointers to function.
Explicitly passing address seems optional, same for notating converter as a pointer.

#+BEGIN_SRC C
#include <stdio.h>

/*
  make a Fahrenheit-Celcuis table using functions.
 */

# define CLOSING_MSG "Goodbye!\n"

float toFahrenheit(float celsius);
float toCelcius(float fahrenheit);
void printTable( float (*converter)(float), char[], char[], int, int, int);

int main() {
  /* int fahr, celsius; */
  printf("To begin, some fahrenheit\n");

  printTable(&toCelcius, "F", "C", 0, 212, 20);

  printf("And now, for some celcuis\n");

  printTable(&toFahrenheit, "C", "F", 0, 100, 10);

  printf(CLOSING_MSG);
}

float toFahrenheit(float celsius) { return ((celsius * 9) / 5.0) + 32; }

float toCelcius(float fahrenheit) { return (5 * (fahrenheit - 32)) / 9.0; }

void printTable(float (*converter)(float), char unitA[], char unitB[], int lower, int upper, int step) {

  for (int i = upper; i >= lower; i = i - step) {
    printf("%6.2f < %s ~ %s > %6.2f\n", (float) i, unitA, unitB, (*converter)(i));
  }
}
#+END_SRC

** 1-16

To print the length of arbitrarily long input lines we separate counting the length of a line from the copy of its (initial) characters.
A while loop runs until the line is over, and inside ~i~ counts up, and also so long as ~i~ is within the limit, the ~i~ th character is copied.

Delicate part is terminating the array.
If within the limit, \0 needs to be placed at ~i~.
Else, at the limit (it's not clear so far whether \0 is made present on initialisation).

#+BEGIN_SRC C
  #include <stdio.h>

  #define MAXLINE 10

  int getlinealt(char line[], int lim); /* getline is defined elsewhere */
  void copy(char to[], char from[]);

  /* print longest input line */
  /* ^D in terminal to enter EOF. Useful: stty all  */

  int main()
  {

    int len;
    int max = 0;
    int lineCount = 0;
    char line[MAXLINE];
    char longest[MAXLINE];

    while ((len = getlinealt(line, MAXLINE)) > 0)
      {
	lineCount += 1;
	if (len > max) {
	  max = len;
	  copy(longest, line);
	}
      }

    lineCount += 1;

    if (max > 0) {
      printf("The longest of %d lines had %d characters.\n", lineCount, max);
      printf("The longest line (up to a limit of %d characters) was:\n", (MAXLINE - 1));
      printf("%s\n", longest);
    }

    return 0;
  }

  int getlinealt(char s[], int lim)
  {
    int c;
    int i = 0;

    while ((c = getchar()) != EOF && c != '\n') {

      if (i < (lim - 1)) {
	s[i] = c;
      }
      ++i;
    }

    if (i < (lim - 1)) { // count \n char.
      if (c == '\n') {
	s[i] = c;
	++i;
      }
      s[i] = '\0';
    }
    else {
      s[lim - 1] = '\0';
    }

    return i;
  }

  void copy(char to[], char from[])
  {
    int i = 0;

    while ((to[i] = from[i]) != '\0')
      ++i;
  }
#+END_SRC

** 1-17

Printing all input lines longer than 80 characters is a quick variant to the previous.
Rather than testing for max and printing at the end, test for min and print if above limit.

#+BEGIN_SRC C
  int main()
  {
    int len;
    int min = 80;
    char line[MAXLINE];
    char longest[MAXLINE];

    while ((len = getlinealt(line, MAXLINE)) > 0)
      {
	if (len > min) {
	  copy(longest, line);
	  printf("The previous line was over %d characters.\n", min);
	  printf("Here it is (up to the first %d characters) again:\n%s\n", (MAXLINE - 1), longest);
	}
      }

    return 0;
  }
#+END_SRC

I guess these exercises are a little more interesting with a terminal that doesn't print input…

** 1-18

The issue is there may be an arbitrary number of blanks and/or tabs.

Dealing with either in isolation is simple.
'Delete' any blank/tab by default and keep a counter of how many have been deleted.
If a character (or than b/t/n) follows, 'restore' the deleted blank/tabs.

But, with b/t interleaved, things are a little more difficult.

An array can be used to store some b/t interleaving.

The order of t/b may matter too, as tabs could be used as a separator for a table, etc.
(Not that it would make much sense to delete trailing t/b in this case without some other ops.)

At the moment I don't see a way to do this generally.

The argument for this being impossible is:

Suppose possible.
Then, we have a way to recover arbitrarily large information using tools which require prespecified size and do not allow increasing such specified size.
So, there is a finite limit on the memory required to store an arbitrary amount of data.
But, that's not possible.

So, there's a trade-off.

- Store a sequence of b/t and then print regardless if run out of storage.
  - No 'inner' b/ts are lost, but trailing b/t's may be present.
- Store a sequnece of b/t and then discard if run out of storage.
  - 'Inner' b/ts may be lost, but not trailing b/ts.

The former seems more sensible, so let's go with the latter.

Typed up, the latter approach is mostly a lot of if's and for's.
Making sure the array is clean is important, and this could be placed in a separate function.

#+BEGIN_SRC C
#include <stdio.h>

#define MAXLINE 4

int cleanLine(int lim); /* getline is defined elsewhere */

/* print longest input line */
/* ^D in terminal to enter EOF. Useful: stty all  */

int main()
{
  cleanLine(MAXLINE);
  return 0;
}

int cleanLine(int lim)
{

  int blankTab[lim];
  for (int i = 0; i < lim; i++) {
    blankTab[i] = 0;
  }

  int c;
  int bti = 0; // position for blank (even) /tab (odd)

  while ((c = getchar()) != EOF) {

    if (c == '\n') {
      // remove blanks
      for (int i = 0; i < lim; i++) {
	blankTab[i] = 0;
      }
      putchar('\n');
      bti = 0;
    }
    else if (c == ' ' && bti < lim) {
      // blank so check index is even
      if (bti % 2 == 1) {
	++bti;
      }
      blankTab[bti] += 1;
    }
    else if (c == '\t' && bti < lim) {
      // tab so
      if (bti % 2 == 0) {
	++bti;
      }
      blankTab[bti] += 1;
    }
    // character case
    else {
      for (int j = 0; j < (bti + 1); j++) { // use bti to avoid searching blanksx
	if (j % 2 == 0) {
	  for (int k = 0; k < blankTab[j]; k++) {
	    putchar(' ');
	  }
	}
	else if (j % 2 == 1) {
	  for (int k = 0; k < blankTab[j]; k++) {
	    putchar('\t');
	  }
	}
	blankTab[j] = 0;
      }
      putchar(c);
      bti = 0;
    }
  }
  return 1;
}
#+END_SRC

** 1-19

*** reverse

Reverse is fairly simple.
Figure out the length of the string array.
Ignore the trailing \0.
Then, swap characters from either end moving inwards.
To do this we need a store (~swap~) for a single char and nothing else.

#+BEGIN_SRC C
  #include <stdio.h>

  int reverse(char s[]);

  int main()
  {

    char word[] = "Hello, there.";
    printf("Input:\n\t%s", word);
    reverse(word);
    printf("\nReversed:\n\t%s\n", word);

    return 0;
  }

  int reverse(char s[])
  {
    int left = 0;
    int right = 0;
    char swap;

    for (right = 0; s[right] != '\0'; right++) {}

    --right;

    while (right - left > 0) {
      swap = s[left];
      s[left] = s[right];
      s[right] = swap;
      ++left;
      --right;
    }

    return 1;
  }
#+END_SRC

*** reversing input lines

To reverse input lines we store as much of the line as possible in an array.

#+BEGIN_SRC C
int main()
{

  char c;
  char stringStore[MAXLINE];
  for (int i = 0; i < MAXLINE; i++) { stringStore[i] = '\0'; }
  int pos = 0;

  while ((c = getchar()) != EOF) {
    if (c == '\n') {
      reverse(stringStore);
      printf("%s\n", stringStore);
      for (int i = 0; i < MAXLINE; i++) {
	stringStore[i] = '\0';
      }
      pos = 0;
    }
    else {
      stringStore[pos] = c;
      ++pos;
    }
  }

  return 0;
}
#+END_SRC

** 1-20

Needed some clarification on this!

https://stackoverflow.com/questions/7178201/kr-exercise-1-20-need-some-clarification

n specifies the distance between tab stops.

So, the task is to keep track of how far the next tab stop is.

This is nice to do when reading a character at a time.
With an array, this is doable, but a little more effort.
We'd need to set a limit on the line width and then shift every character the relevant number of spaces left/right.

~main~ calls ~detab~ and ~STOPDIST~ is a symbolic constant.

#+BEGIN_SRC C
  void detab(void)
  {
    int afterTab = 0;
    char c;

    while ((c = getchar()) != EOF) {

      if (c == '\t') {
	for (int i = STOPDIST - afterTab; i > 0; i--) {
	  putchar(' ');
	}
	afterTab = 0;
      }
      else {
	putchar(c);
	if (c == '\n') {
	  afterTab = 0;
	} else {
	  afterTab = ((afterTab + 1) % STOPDIST);
	}
      }
    }
  }
#+END_SRC

** 1-21

Similar to detab.

Given anything other than a space we re-add any skipped spaces not taken up by a tab.
Then, add the char and update distance after a tabstop.

With spaces, keep a count and when a tabstop is past, add a tab and reset the counters.

#+BEGIN_SRC C
void entab(void)
{

  int spacesSeen = 0;
  int afterTab = 0;
  char c;

  while ((c = getchar()) != EOF) {

    if (c == ' ') {
      ++spacesSeen;
      if ((afterTab + spacesSeen) == STOPDIST) {
	putchar('\t');
	afterTab = 0;
	spacesSeen = 0;
      }
    }
    else {
      while (spacesSeen > 0) {
	putchar(' ');
	--spacesSeen;
	++afterTab;
      }
      putchar(c);
      ++afterTab;

      afterTab = afterTab % STOPDIST;
    }
  }
}
#+END_SRC

This was kind of difficult, if only due to thinking about tab stops and the importance of keeping track of both spaces /and/ characters.

** 1-22

These exercises seem strange.
If we're manipulating text, then surely we want a different data strucutre?

In particular some kind of linked list.

The elements of the list could be chars, though word arrays would be better.
The point being we'd like to do surgery on a small part of the input.

Here, I think the appropriate response is to read input into an array equal to line length.
Then, when this is full work out how much is safe to print.
Finally, move anything remaining to the start of the array.

Okay, on reflection this sounds like the kind of thing one would do to display text.

Stopping now before I have too much fun!

The basic idea is as above.
~lineBuffer~ stores characters to display and is processed when full.
Different cases for nice display annotated below.

Hyphenation is very basic, but I know this requires a lot of work to be nice.

Tabs are converted to a single space as I'm not sure what I want to do with these.
As a character I think it's fine to print, even if initial on row.

#+BEGIN_SRC C
  #include <stdio.h>

  #define CWIDTH 5

  int countText(char text[]);
  void fold(char input[]);
  void shiftCharsLeft(char s[], int sLength, int from, int spaces);

  int main()
  {
    char t[] = "This is a piece of text with some extrodinarily long words";
    printf("%s\n", t);
    printf("Folded to width %d:\n", CWIDTH);
    fold(t);

    return 0;
  }

  void fold(char input[])
  {

    char lineBuffer[CWIDTH];
    int bufferIndex = 0;
    int lastSpace = -1;

    int inputLength =  countText(input);

    for (int i = 0; input[i] != '\0'; i++) {

      // skip any initial spaces
      if (bufferIndex == 0 && input[i] == ' ') { ++i; }

      // copy current char and make not if empty
      if (input[i] = '\t') {
	lineBuffer[bufferIndex] = ' ';
      } else {
      lineBuffer[bufferIndex] = input[i];
      }
      if (input[i] == ' ') {
	lastSpace = bufferIndex;
      }
      ++bufferIndex;

      // when buffer is full
      if (bufferIndex == CWIDTH) {

	// if space was found
	if (lastSpace > 0) {
	  // display until spacea
	  for (int j = 0; j < lastSpace; j++) {
	    putchar(lineBuffer[j]);
	  }
	  putchar('\n');
	  // move everything after to front of buffer
	  shiftCharsLeft(lineBuffer, CWIDTH, lastSpace + 1, lastSpace + 1);
	  // point to after everything just moved for next char
	  bufferIndex = CWIDTH - (lastSpace + 1);
	  lastSpace = -1;
	}
	// if full and space or newline next ignore these.
	else if ((i + 1) < inputLength && ((input[i + 1] == ' ') || (input[i + 1] == '\n'))) {
	  for (int j = 0; j < CWIDTH; j++) {
	    putchar(lineBuffer[j]);
	  }
	  putchar('\n');
	  lastSpace = -1;
	  bufferIndex = 0;
	}
	else if ((i + 1) == inputLength) {
	  // skip as empty buffer at end
	}
	// need to break the word.
	else {
	  // print as much as possible leaving room...
	  for (int j = 0; j < (CWIDTH - 1); j++) {
	    putchar(lineBuffer[j]);
	  }
	  // for a hyphen.
	  putchar('-');
	  putchar('\n');
	  // keep leftover char
	  shiftCharsLeft(lineBuffer, CWIDTH, (CWIDTH - 1), (CWIDTH - 1));
	  bufferIndex = 1;
	  lastSpace = -1;
	}
      }
    }
    // display anything remaining in buffer
    for (int j = 0; j < CWIDTH; j++) {
      putchar(lineBuffer[j]);
    }
    putchar('\n');
  }

  int countText(char text[]) {
    int i;
    for (i = 0; text[i] != '\0'; i++) {}
    return i;
  }

  void shiftCharsLeft(char s[], int sLength, int from, int spaces)
  {
    for (int i = from; i < sLength; i++) {
      s[i - spaces] = s[i];
    }
    // cleanup
    for (int i = sLength - from; i < sLength; i++) {
      s[i] = '\0';
    }
  }
#+END_SRC


* chapter 2

** 2-1

The first approach is to use a larger type to calculate the bounds of a smaller type.
For ~char~, ~short~, ~int~, and ~long~ max, the following template works:

Note, the explicit casts to ~char~ need to be updated for ~long~, etc.
These are needed to ensure we're testing for equal representation with respect to the types of interest.

Work is done by approximation.
Start with 1 and then double this until equality fails to hold on next double.
Then, keep adding fractions of the current result until equality breaks.

The idea here for max is to approximate by addition, but to grow the amount to be added fairly fast.
And, repeat this until there's nothing more to be added without breaking equality.

Likewise for min, but with subtraction.

Float works here, but gives a different result compared to ~FLT_MAX~ and ~FLT_MIN~.
(1.67772e+07 max and +1 does nothing.)

#+BEGIN_SRC C
  #include <stdio.h>

  int main() {

    double dbl = 1;
    char max = 1;

    while ((dbl + 1) == (char) (max + 1)) {

      double j = 1;

      while (((dbl + (j * 2)) == (char) (max + (j * 2))) ) { j = j * 2; }

      dbl = dbl + j;
      max = max + j;
      }

    dbl = 1;
    char min = 1;

    while ((dbl - 1) == (char) (min - 1)) {

      double j = 1;

      while ((dbl - (j * 2)) == (char) (min - (j * 2))) { j = j * 2; }

      dbl = dbl - j;
      min = min - j;
    }

    printf("\nFinal results:\n \tMax: %d\n \tMin: %d\n", max, min);

    }
#+END_SRC

Maybe a different approach was intended, as I don't think casting has been introduced yet.
Though, this can be avoided with some 'temporary' variables, or altered tests.
