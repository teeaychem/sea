#+STARTUP: Overview
#+PROPERTY: header-args :noweb eval :results output
#+TITLE: K & R Exercises

* chapter 1

** 1.1

#+BEGIN_SRC C
  #include <stdio.h>

  int main()
  {
    printf("Hello, world!\n");
  }
#+END_SRC

#+RESULTS:

** 1.2

~\o~ is related to ~\0~?

** 1.3

Included in Ex. 4, though formatting other than a heading.

** 1.4

Inluced in Ex. 5

** 1.5

Straightfoward, with a few additions for testing whether constants are limited to ints (no).

#+BEGIN_SRC C
#include <stdio.h>

/*
  make a Fahrenheit-Celcuis table
 */

# define LOWER 0
# define FUPPER 212
# define FSTEP 20
# define CUPPER 100
# define CSTEP 7.532
/* No typing with symbolic constants… */

# define CLOSING_MSG "Goodbye!\n"
/*
  What's stored is determined.
  But, what about interpreting the bits?
 */


int main() {
  /* int fahr, celsius; */
  float celsius, fahr;

  printf("To begin, some fahrenheit\n");
  celsius = 0;

  /*
    No restriction on test condition. But need everything initialised.
    So, test before first instance, allowing to skip entirely.
  */
  for (fahr = FUPPER; celsius >= LOWER; fahr = fahr - FSTEP) {

    celsius = (5 * (fahr - 32)) / 9.0;
    printf("%6.2f < c ~ f > %6.2f\n", celsius, fahr);
  }

  printf("And now, for some celcuis\n");

  for (celsius = CUPPER; celsius >= LOWER; celsius = celsius - CSTEP) {
    fahr = ((celsius * 9) / 5.0) + 32;
    printf("%6.2f < c ~ f > %6.2f\n", celsius, fahr);
  }

  printf(CLOSING_MSG);
}

#+END_SRC

#+RESULTS:
#+begin_example
To begin, some fahrenheit
100.00 < c ~ f > 212.00
 88.89 < c ~ f > 192.00
 77.78 < c ~ f > 172.00
 66.67 < c ~ f > 152.00
 55.56 < c ~ f > 132.00
 44.44 < c ~ f > 112.00
 33.33 < c ~ f >  92.00
 22.22 < c ~ f >  72.00
 11.11 < c ~ f >  52.00
  0.00 < c ~ f >  32.00
-11.11 < c ~ f >  12.00
And now, for some celcuis
100.00 < c ~ f > 212.00
 92.47 < c ~ f > 198.44
 84.94 < c ~ f > 184.88
 77.40 < c ~ f > 171.33
 69.87 < c ~ f > 157.77
 62.34 < c ~ f > 144.21
 54.81 < c ~ f > 130.65
 47.28 < c ~ f > 117.10
 39.74 < c ~ f > 103.54
 32.21 < c ~ f >  89.98
 24.68 < c ~ f >  76.42
 17.15 < c ~ f >  62.87
  9.62 < c ~ f >  49.31
  2.08 < c ~ f >  35.75
Goodbye!
#+end_example

** 1.6

The parentheses aren't really required.
And, it's fine to set ~val~ as either ~char~ or ~int~ with ~%d~.
Things get messy with ~%s~.

#+BEGIN_SRC C
  #include <stdio.h>

  int val;
  char c;

  int main() {
    val = ((c = getchar()) != EOF);
    printf("%d", val);
  }
#+END_SRC

** 1.7

Extends 6 and prints things a little more elegantly.

#+BEGIN_SRC C
  #include <stdio.h>

  int val;
  char c;

  int main()
  {
   val = ((c = getchar()) != EOF);

   printf("You entered %c\n" , c);
   printf("Testing whether %c is not equal to EOF returns %d\n", c, val);

   printf("Also, if we try to print EOF the result is:\n");
   printf("%c - with c\n", EOF);
   printf("%d - with d\n", EOF);
   printf("Goodbye!\n", EOF);
   }
#+END_SRC

Sample output is

#+BEGIN_SRC C
  t
  You entered t
  Testing whether t is not equal to EOF returns 1
  Also, if we try to print EOF the result is:
  � - with c
  -1 - with d
  Goodbye!
#+END_SRC

So, there's no associated character (go figure!) and EOF is neither truthy or falsey.

** 1.8

#+BEGIN_SRC C
  #include <stdio.h>

  int main() {

    long charCount;
    int lineCount, tabCount, blankCount;
    char c;

    charCount = 0;
    lineCount = 0;
    tabCount = 0;
    blankCount = 0;

    while ((c = getchar()) != EOF) {

      if (c == '\n') {
	++lineCount;
      }
      else if (c == ' ') {
	++blankCount;
      }
      else if (c == '\t') {
	++tabCount;
      }
      else {
	++charCount;
      }
    }

    printf("The text contained:\n");
    printf("%d lines\n", lineCount);
    printf("%d tabs\n", tabCount);
    printf("%d blank characters\n", blankCount);
    printf("%ld (non-blank) characters\n", charCount);
    printf("Goodbye!\n");
  }
#+END_SRC

As multiple things are testing for each run of the loop a ~for~ construction doesn't make sense here.
Could drop brackets around all the conditions.
Could do more to format the results.

** 1.9

A little messy.
Set up a counter for number of blank chars seen, print only when this is less than 1.
Not ideal if wish to do similar things with different chars, as each other check needs to rest.

#+BEGIN_SRC C
  #include <stdio.h>

  int main() {

    long charCount;
    int lineCount, tabCount, blankCount, previousBlank, blanksLost;
    char c;

    charCount = 0;
    lineCount = 0;
    tabCount = 0;
    blankCount = 0;
    previousBlank = 0;
    blanksLost = 0;

    while ((c = getchar()) != EOF) {

      if (c == ' ') {
	++blankCount;
	++previousBlank;
      }
      else {
	if (c == '\n') {
	  ++lineCount;
	}
	else if (c == '\t') {
	  ++tabCount;
	}
	else {
	  ++charCount;
	}
	if (previousBlank > 1) {
	  blanksLost = blanksLost + (previousBlank - 1);
	}
	previousBlank = 0;
      }

      if (previousBlank < 2) {
	putchar(c);
      }
    }

    printf("The text contained:\n");
    printf("%d lines\n", lineCount);
    printf("%d tabs\n", tabCount);
    printf("%d blank characters (%d were lost)\n", blankCount, blanksLost);
    printf("%ld (non-blank) characters\n", charCount);
    printf("Goodbye!\n");
  }
#+END_SRC

** 1.10

Getting even more messy.
If a replacement is needed, signal to first output ~\~ and update ~c~ to relevant char.
Note, special case for newline, as to make things look nice, we want to both display ~\n~ and also still print a newline.

#+BEGIN_SRC C
  #include <stdio.h>

int main() {

  long charCount;
  int lineCount, tabCount, blankCount, previousBlank, blanksLost, replacement;
  char c;

  charCount = 0;
  lineCount = 0;
  tabCount = 0;
  blankCount = 0;
  previousBlank = 0;
  blanksLost = 0;
  replacement = 0;

  while ((c = getchar()) != EOF) {

    replacement = 0;

    if (c == ' ') {
      ++blankCount;
      ++previousBlank;
    }
    else {
      if (c == '\n') {
	c = 'n';
	++lineCount;
	replacement = 2; /* special case to flag newline still needed */
      }
      if (c == '\t') {
	c = 't';
	++tabCount;
	replacement = 1;
      }
      if (c == '\\') {
	replacement = 1;
      }

      if (replacement > 0) {
	putchar('\\');
      }
      else {
	++charCount;
      }
      if (previousBlank > 1) {
	blanksLost = blanksLost + (previousBlank - 1);
      }
      previousBlank = 0;
    }

    if (previousBlank < 2) {
      putchar(c);
      if (replacement == 2) {
	putchar('\n');
      }
    }
  }

  printf("The text contained:\n");
  printf("%d lines\n", lineCount);
  printf("%d tabs\n", tabCount);
  printf("%d blank characters (%d were lost)\n", blankCount, blanksLost);
  printf("%ld (non-blank) characters\n", charCount);
  printf("Goodbye!\n");
}
#+END_SRC

Backspace is difficult.

Following the above, the case would be:

#+BEGIN_SRC C
  if (c == '\b') {
    c = 'b';
    replacement = 1;
  }
#+END_SRC

However, characters are only passed on after pressing enter.
So, there's no way to pass on a backspace.

Note, this has various effects, esp. with respect to when a newline is or isn't printed.

** 1.11

Test the word count program against some texts where the count is known.
In particular, texts which include a variety of characters, esp. special characters.

For example, what happens with numbers?

Should 21 be no words, one word ('21' or 'twenty-one'), or two words (twenty one)?

Similarly, what about (3/11)?

And, what happens with something like ^B (the backspace char)?

** 1.12

Moslty a modification of word counting in the text.
Just, without the counting, and the body of empty case involving a flag.

#+BEGIN_SRC C
#include <stdio.h>

#define IN 1
#define OUT 0

int main() {

  int c, state;
  state = OUT;

  while ((c = getchar()) != EOF) {
    if (c == ' ' || c == '\t') {
      if (state == IN) {
	putchar('\n');
	state = OUT;
      }
    } else {
      state = IN;
      putchar(c);
    }
  }
}
#+END_SRC

** 1.13

Histogram in vertical orientaion.

Most interesting thing here is resizing the array to deal with arbitrary word legnths.
It just works to allocate more!

Sample output:

#+BEGIN_SRC C
  a a a
  bb bb
  ccc ccc ccc ccc ccc
  dddd
  eeeeee eeeeee
  fffffff
  ggggggggg ggggggggg ggggggggg

	 |
	 |
   |     |                 |
   |  |  |        |        |
   |  |  |  |     |  |     |
   1  2  3  4  5  6  7  8  9
#+END_SRC

For the histogram, figure out the maximum count, then work down to 0 printing a bar whenever the count for the number is within the scope.
This uses a lot of for loops, and some things could be tidied up a little.

*** proc

Variables named like this aren't much better than magic numbers…

#+BEGIN_SRC C
  #include <stdio.h>

  #define IN 1
  #define OUT 0

  int main() {

    int i, j, c, wc, state, old_wl, new_wl, max_wl;

    wc = max_wl = old_wl = 0;
    new_wl = 2;
    int wl[new_wl];
    state = OUT;

    for (i = old_wl; i < new_wl; ++i) {
      wl[i] = 0;
    }

    while ((c = getchar()) != EOF) {
      if (c == ' ' || c == '\t' || c == '\n') {
	if (state == IN) {
	  state = OUT;

	  if (wc >= new_wl) { /* extend the array if needed */
	    old_wl = new_wl;
	    new_wl = wc;
	    for (i = old_wl; i < new_wl; ++i) {
	      wl[i] = 0;
	    }
	  }

	  ++wl[wc - 1];
	  wc = 0;
	}
      } else {
	state = IN;
	++wc;
      }
    }

    /* figure out max word length could
       be done while building but assume
       fewer lengths than words
    ,*/
    for (i = 0; i < new_wl; ++i) {
      if (wl[i] > max_wl) {
	max_wl = wl[i];
      }
    }

    /* make histogram.
       go from the max length down and print
       a bar if count exceeds current
    ,*/
    for (i = max_wl; i >= 0; --i) {
      for (j = 0; j < new_wl; ++j) {
	if (wl[j] > i) {
	  printf(" | ");
	} else {
	  printf("   ");
	}
      }
      printf("\n");
    }
    /* finish off with integer */
    for (j = 1; j <= new_wl; ++j) {
      printf(" %d ", j);
    }
    printf("\n");
  }
#+END_SRC
