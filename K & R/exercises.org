#+STARTUP: Overview
#+PROPERTY: header-args :noweb eval :results output
#+TITLE: K & R Exercises

* chapter 1

** 1-1

#+BEGIN_SRC C
  #include <stdio.h>

  int main()
  {
    printf("Hello, world!\n");
  }
#+END_SRC

#+RESULTS:

** 1-2

~\o~ is related to ~\0~?

** 1-3

Included in Ex. 4, though formatting other than a heading.

** 1-4

Inluced in Ex. 5

** 1-5

Straightfoward, with a few additions for testing whether constants are limited to ints (no).

#+BEGIN_SRC C
#include <stdio.h>

/*
  make a Fahrenheit-Celcuis table
 */

# define LOWER 0
# define FUPPER 212
# define FSTEP 20
# define CUPPER 100
# define CSTEP 7.532
/* No typing with symbolic constants… */

# define CLOSING_MSG "Goodbye!\n"
/*
  What's stored is determined.
  But, what about interpreting the bits?
 */


int main() {
  /* int fahr, celsius; */
  float celsius, fahr;

  printf("To begin, some fahrenheit\n");
  celsius = 0;

  /*
    No restriction on test condition. But need everything initialised.
    So, test before first instance, allowing to skip entirely.
  */
  for (fahr = FUPPER; celsius >= LOWER; fahr = fahr - FSTEP) {

    celsius = (5 * (fahr - 32)) / 9.0;
    printf("%6.2f < c ~ f > %6.2f\n", celsius, fahr);
  }

  printf("And now, for some celcuis\n");

  for (celsius = CUPPER; celsius >= LOWER; celsius = celsius - CSTEP) {
    fahr = ((celsius * 9) / 5.0) + 32;
    printf("%6.2f < c ~ f > %6.2f\n", celsius, fahr);
  }

  printf(CLOSING_MSG);
}

#+END_SRC

#+RESULTS:
#+begin_example
To begin, some fahrenheit
100.00 < c ~ f > 212.00
 88.89 < c ~ f > 192.00
 77.78 < c ~ f > 172.00
 66.67 < c ~ f > 152.00
 55.56 < c ~ f > 132.00
 44.44 < c ~ f > 112.00
 33.33 < c ~ f >  92.00
 22.22 < c ~ f >  72.00
 11.11 < c ~ f >  52.00
  0.00 < c ~ f >  32.00
-11.11 < c ~ f >  12.00
And now, for some celcuis
100.00 < c ~ f > 212.00
 92.47 < c ~ f > 198.44
 84.94 < c ~ f > 184.88
 77.40 < c ~ f > 171.33
 69.87 < c ~ f > 157.77
 62.34 < c ~ f > 144.21
 54.81 < c ~ f > 130.65
 47.28 < c ~ f > 117.10
 39.74 < c ~ f > 103.54
 32.21 < c ~ f >  89.98
 24.68 < c ~ f >  76.42
 17.15 < c ~ f >  62.87
  9.62 < c ~ f >  49.31
  2.08 < c ~ f >  35.75
Goodbye!
#+end_example

** 1-6

The parentheses aren't really required.
And, it's fine to set ~val~ as either ~char~ or ~int~ with ~%d~.
Things get messy with ~%s~.

#+BEGIN_SRC C
  #include <stdio.h>

  int val;
  char c;

  int main() {
    val = ((c = getchar()) != EOF);
    printf("%d", val);
  }
#+END_SRC

** 1-7

Extends 6 and prints things a little more elegantly.

#+BEGIN_SRC C
  #include <stdio.h>

  int val;
  char c;

  int main()
  {
   val = ((c = getchar()) != EOF);

   printf("You entered %c\n" , c);
   printf("Testing whether %c is not equal to EOF returns %d\n", c, val);

   printf("Also, if we try to print EOF the result is:\n");
   printf("%c - with c\n", EOF);
   printf("%d - with d\n", EOF);
   printf("Goodbye!\n", EOF);
   }
#+END_SRC

Sample output is

#+BEGIN_SRC C
  t
  You entered t
  Testing whether t is not equal to EOF returns 1
  Also, if we try to print EOF the result is:
  � - with c
  -1 - with d
  Goodbye!
#+END_SRC

So, there's no associated character (go figure!) and EOF is neither truthy or falsey.

** 1-8

#+BEGIN_SRC C
  #include <stdio.h>

  int main() {

    long charCount;
    int lineCount, tabCount, blankCount;
    char c;

    charCount = 0;
    lineCount = 0;
    tabCount = 0;
    blankCount = 0;

    while ((c = getchar()) != EOF) {

      if (c == '\n') {
	++lineCount;
      }
      else if (c == ' ') {
	++blankCount;
      }
      else if (c == '\t') {
	++tabCount;
      }
      else {
	++charCount;
      }
    }

    printf("The text contained:\n");
    printf("%d lines\n", lineCount);
    printf("%d tabs\n", tabCount);
    printf("%d blank characters\n", blankCount);
    printf("%ld (non-blank) characters\n", charCount);
    printf("Goodbye!\n");
  }
#+END_SRC

As multiple things are testing for each run of the loop a ~for~ construction doesn't make sense here.
Could drop brackets around all the conditions.
Could do more to format the results.

** 1-9

A little messy.
Set up a counter for number of blank chars seen, print only when this is less than 1.
Not ideal if wish to do similar things with different chars, as each other check needs to rest.

#+BEGIN_SRC C
  #include <stdio.h>

  int main() {

    long charCount;
    int lineCount, tabCount, blankCount, previousBlank, blanksLost;
    char c;

    charCount = 0;
    lineCount = 0;
    tabCount = 0;
    blankCount = 0;
    previousBlank = 0;
    blanksLost = 0;

    while ((c = getchar()) != EOF) {

      if (c == ' ') {
	++blankCount;
	++previousBlank;
      }
      else {
	if (c == '\n') {
	  ++lineCount;
	}
	else if (c == '\t') {
	  ++tabCount;
	}
	else {
	  ++charCount;
	}
	if (previousBlank > 1) {
	  blanksLost = blanksLost + (previousBlank - 1);
	}
	previousBlank = 0;
      }

      if (previousBlank < 2) {
	putchar(c);
      }
    }

    printf("The text contained:\n");
    printf("%d lines\n", lineCount);
    printf("%d tabs\n", tabCount);
    printf("%d blank characters (%d were lost)\n", blankCount, blanksLost);
    printf("%ld (non-blank) characters\n", charCount);
    printf("Goodbye!\n");
  }
#+END_SRC

** 1-10

Getting even more messy.
If a replacement is needed, signal to first output ~\~ and update ~c~ to relevant char.
Note, special case for newline, as to make things look nice, we want to both display ~\n~ and also still print a newline.

#+BEGIN_SRC C
  #include <stdio.h>

int main() {

  long charCount;
  int lineCount, tabCount, blankCount, previousBlank, blanksLost, replacement;
  char c;

  charCount = 0;
  lineCount = 0;
  tabCount = 0;
  blankCount = 0;
  previousBlank = 0;
  blanksLost = 0;
  replacement = 0;

  while ((c = getchar()) != EOF) {

    replacement = 0;

    if (c == ' ') {
      ++blankCount;
      ++previousBlank;
    }
    else {
      if (c == '\n') {
	c = 'n';
	++lineCount;
	replacement = 2; /* special case to flag newline still needed */
      }
      if (c == '\t') {
	c = 't';
	++tabCount;
	replacement = 1;
      }
      if (c == '\\') {
	replacement = 1;
      }

      if (replacement > 0) {
	putchar('\\');
      }
      else {
	++charCount;
      }
      if (previousBlank > 1) {
	blanksLost = blanksLost + (previousBlank - 1);
      }
      previousBlank = 0;
    }

    if (previousBlank < 2) {
      putchar(c);
      if (replacement == 2) {
	putchar('\n');
      }
    }
  }

  printf("The text contained:\n");
  printf("%d lines\n", lineCount);
  printf("%d tabs\n", tabCount);
  printf("%d blank characters (%d were lost)\n", blankCount, blanksLost);
  printf("%ld (non-blank) characters\n", charCount);
  printf("Goodbye!\n");
}
#+END_SRC

Backspace is difficult.

Following the above, the case would be:

#+BEGIN_SRC C
  if (c == '\b') {
    c = 'b';
    replacement = 1;
  }
#+END_SRC

However, characters are only passed on after pressing enter.
So, there's no way to pass on a backspace.

Note, this has various effects, esp. with respect to when a newline is or isn't printed.

** 1-11

Test the word count program against some texts where the count is known.
In particular, texts which include a variety of characters, esp. special characters.

For example, what happens with numbers?

Should 21 be no words, one word ('21' or 'twenty-one'), or two words (twenty one)?

Similarly, what about (3/11)?

And, what happens with something like ^B (the backspace char)?

** 1-12

Moslty a modification of word counting in the text.
Just, without the counting, and the body of empty case involving a flag.

#+BEGIN_SRC C
#include <stdio.h>

#define IN 1
#define OUT 0

int main() {

  int c, state;
  state = OUT;

  while ((c = getchar()) != EOF) {
    if (c == ' ' || c == '\t') {
      if (state == IN) {
	putchar('\n');
	state = OUT;
      }
    } else {
      state = IN;
      putchar(c);
    }
  }
}
#+END_SRC

** 1-13

Histogram in vertical orientaion.

Sample output:

#+BEGIN_SRC C
  a a a
  bb bb
  ccc ccc ccc ccc ccc
  dddd
  eeeeee eeeeee
  fffffff
  ggggggggg ggggggggg ggggggggg

	 |
	 |
   |     |                 |
   |  |  |        |        |
   |  |  |  |     |  |     |
   1  2  3  4  5  6  7  8  9
#+END_SRC

For the histogram, figure out the maximum count, then work down to 0 printing a bar whenever the count for the number is within the scope.
This uses a lot of for loops, and some things could be tidied up a little.

A highly dodgy initial version of the program is preserved a revised version.

*** prog

Note, the maximum word length is specified, and array is initialised to this length, and we only add a count to the record when the word length falls within the maximum.
The size of arrays is fixed, and things go wrong is this is forgotten about.

#+BEGIN_SRC C
#include <stdio.h>

#define IN 1
#define OUT 0
#define MAX_WL 20

  int main() {

    int i, j, c, wc, state, top_wf, top_wl;

    wc = top_wf = top_wl = 0;
    int wl[MAX_WL];
    state = OUT;

    for (i = 0; i < MAX_WL; ++i) {
      wl[i] = 0;
    }

    while ((c = getchar()) != EOF) {
      if (c == ' ' || c == '\t' || c == '\n') {
	if (state == IN) {
	  state = OUT;
	  if (wc <= MAX_WL) {
	    ++wl[wc - 1]; /* no need to count 0 */
	  }
	  wc = 0;
	}
      } else {
	state = IN;
	++wc;
      }
    }

    /* figure out max word length could
       be done while building but assume
       fewer lengths than words
    */
    for (i = 0; i < MAX_WL; ++i) {
      if (wl[i] != 0) {
	top_wl = i + 1;
	if (wl[i] > top_wf) {
	  top_wf = wl[i];
	}
      }
    }

    /* make histogram.
       go from the max length down and print
       a bar if count exceeds current
    */
    for (i = top_wf; i >= 0; --i) {
      for (j = 0; j < top_wl; ++j) {
	if (wl[j] > i) {
	  printf("  |");
	} else {
	  printf("   ");
	}
      }
      printf("\n");
    }
    /* finish off with integer */
    for (j = 0; j < top_wl; ++j) {
      printf("%3d", j + 1);
    }
    printf("\n");
  }#+END_SRC

*** bad prog

Variables named like this aren't much better than magic numbers…

I'm not sure why I thought this worked as I don't to anything to suggest the length of wl has been updated.
All I do is continue to write past the space allocated to wl and hope things work out.

#+BEGIN_SRC C
  #include <stdio.h>

  #define IN 1
  #define OUT 0

  int main() {

    int i, j, c, wc, state, old_wl, new_wl, max_wl;

    wc = max_wl = old_wl = 0;
    new_wl = 2;
    int wl[new_wl];
    state = OUT;

    for (i = old_wl; i < new_wl; ++i) {
      wl[i] = 0;
    }

    while ((c = getchar()) != EOF) {
      if (c == ' ' || c == '\t' || c == '\n') {
	if (state == IN) {
	  state = OUT;

	  if (wc >= new_wl) { /* extend the array if needed */
	    old_wl = new_wl;
	    new_wl = wc;
	    for (i = old_wl; i < new_wl; ++i) {
	      wl[i] = 0;
	    }
	  }
	  ++wl[wc - 1];
	  wc = 0;
	}
      } else {
	state = IN;
	++wc;
      }
    }

    /* figure out max word length could
       be done while building but assume
       fewer lengths than words
    ,*/
    for (i = 0; i < new_wl; ++i) {
      if (wl[i] > max_wl) {
	max_wl = wl[i];
      }
    }

    /* make histogram.
       go from the max length down and print
       a bar if count exceeds current
    ,*/
    for (i = max_wl; i >= 0; --i) {
      for (j = 0; j < new_wl; ++j) {
	if (wl[j] > i) {
	  printf(" | ");
	} else {
	  printf("   ");
	}
      }
      printf("\n");
    }
    /* finish off with integer */
    for (j = 1; j <= new_wl; ++j) {
      printf(" %d ", j);
    }
    printf("\n");
  }
#+END_SRC

** 1-14

A little easier than counting words as character choices are known beforehand.
Here, lowercase alphabetic characters are counted.
Uppercase could be added by a an additional check and further offset to obtain lowercase value.

*** sample output

#+BEGIN_SRC C
   5                          |              |
   4  |                       |              |  |           |                 |
   3  |                       |     |        |  |           |                 |
   2  |        |  |     |     |     |     |  |  |           |                 |
   1  |        |  |     |     |     |     |  |  |        |  |                 |
   0  |        |  |  |  |  |  |     |     |  |  |  |     |  |  |        |     |  |
      a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z
#+END_SRC

*** prog


#+BEGIN_SRC C
  #include <stdio.h>

  int main() {

    int i, j, c, max_wl;

    max_wl = 0;

    int wl[26];

    for (i = 0; i < 26; ++i) {
      wl[i] = 0;
    }

    while ((c = getchar()) != EOF) {
      if (c >= 'a' && c <= 'z') {
	++wl[c - 'a'];
      }
    }

    for (i = 0; i < 26; ++i) {
      if (wl[i] > max_wl) {
	max_wl = wl[i];
      }
    }

    printf("\n");
    for (i = max_wl - 1; i >= 0; --i) {
      printf(" %3d ", i);
      for (j = 0; j < 26; ++j) {
	if (wl[j] > i) {
	  printf(" | ");
	} else {
	  printf("   ");
	}
      }
      printf("\n");
    }
    printf("     ");
    for (j = 0; j < 26; ++j) {
      printf(" %c ", j + 'a');
    }
    printf("\n");
    }
#+END_SRC

** 1-15

The toFahrenheit and toCelcius functions are simple.

printTable may need some revision.
On current understanding, pass functions by pointers to function.
Explicitly passing address seems optional, same for notating converter as a pointer.

#+BEGIN_SRC C
#include <stdio.h>

/*
  make a Fahrenheit-Celcuis table using functions.
 */

# define CLOSING_MSG "Goodbye!\n"

float toFahrenheit(float celsius);
float toCelcius(float fahrenheit);
void printTable( float (*converter)(float), char[], char[], int, int, int);

int main() {
  /* int fahr, celsius; */
  printf("To begin, some fahrenheit\n");

  printTable(&toCelcius, "F", "C", 0, 212, 20);

  printf("And now, for some celcuis\n");

  printTable(&toFahrenheit, "C", "F", 0, 100, 10);

  printf(CLOSING_MSG);
}

float toFahrenheit(float celsius) { return ((celsius * 9) / 5.0) + 32; }

float toCelcius(float fahrenheit) { return (5 * (fahrenheit - 32)) / 9.0; }

void printTable(float (*converter)(float), char unitA[], char unitB[], int lower, int upper, int step) {

  for (int i = upper; i >= lower; i = i - step) {
    printf("%6.2f < %s ~ %s > %6.2f\n", (float) i, unitA, unitB, (*converter)(i));
  }
}
#+END_SRC

** 1-16

To print the length of arbitrarily long input lines we separate counting the length of a line from the copy of its (initial) characters.
A while loop runs until the line is over, and inside ~i~ counts up, and also so long as ~i~ is within the limit, the ~i~ th character is copied.

Delicate part is terminating the array.
If within the limit, \0 needs to be placed at ~i~.
Else, at the limit (it's not clear so far whether \0 is made present on initialisation).

#+BEGIN_SRC C
  #include <stdio.h>

  #define MAXLINE 10

  int getlinealt(char line[], int lim); /* getline is defined elsewhere */
  void copy(char to[], char from[]);

  /* print longest input line */
  /* ^D in terminal to enter EOF. Useful: stty all  */

  int main()
  {

    int len;
    int max = 0;
    int lineCount = 0;
    char line[MAXLINE];
    char longest[MAXLINE];

    while ((len = getlinealt(line, MAXLINE)) > 0)
      {
	lineCount += 1;
	if (len > max) {
	  max = len;
	  copy(longest, line);
	}
      }

    lineCount += 1;

    if (max > 0) {
      printf("The longest of %d lines had %d characters.\n", lineCount, max);
      printf("The longest line (up to a limit of %d characters) was:\n", (MAXLINE - 1));
      printf("%s\n", longest);
    }

    return 0;
  }

  int getlinealt(char s[], int lim)
  {
    int c;
    int i = 0;

    while ((c = getchar()) != EOF && c != '\n') {

      if (i < (lim - 1)) {
	s[i] = c;
      }
      ++i;
    }

    if (i < (lim - 1)) { // count \n char.
      if (c == '\n') {
	s[i] = c;
	++i;
      }
      s[i] = '\0';
    }
    else {
      s[lim - 1] = '\0';
    }

    return i;
  }

  void copy(char to[], char from[])
  {
    int i = 0;

    while ((to[i] = from[i]) != '\0')
      ++i;
  }
#+END_SRC

** 1-17

Printing all input lines longer than 80 characters is a quick variant to the previous.
Rather than testing for max and printing at the end, test for min and print if above limit.

#+BEGIN_SRC C
  int main()
  {
    int len;
    int min = 80;
    char line[MAXLINE];
    char longest[MAXLINE];

    while ((len = getlinealt(line, MAXLINE)) > 0)
      {
	if (len > min) {
	  copy(longest, line);
	  printf("The previous line was over %d characters.\n", min);
	  printf("Here it is (up to the first %d characters) again:\n%s\n", (MAXLINE - 1), longest);
	}
      }

    return 0;
  }
#+END_SRC

I guess these exercises are a little more interesting with a terminal that doesn't print input…

** 1-18

The issue is there may be an arbitrary number of blanks and/or tabs.

Dealing with either in isolation is simple.
'Delete' any blank/tab by default and keep a counter of how many have been deleted.
If a character (or than b/t/n) follows, 'restore' the deleted blank/tabs.

But, with b/t interleaved, things are a little more difficult.

An array can be used to store some b/t interleaving.

The order of t/b may matter too, as tabs could be used as a separator for a table, etc.
(Not that it would make much sense to delete trailing t/b in this case without some other ops.)

At the moment I don't see a way to do this generally.

The argument for this being impossible is:

Suppose possible.
Then, we have a way to recover arbitrarily large information using tools which require prespecified size and do not allow increasing such specified size.
So, there is a finite limit on the memory required to store an arbitrary amount of data.
But, that's not possible.

So, there's a trade-off.

- Store a sequence of b/t and then print regardless if run out of storage.
  - No 'inner' b/ts are lost, but trailing b/t's may be present.
- Store a sequnece of b/t and then discard if run out of storage.
  - 'Inner' b/ts may be lost, but not trailing b/ts.

The former seems more sensible, so let's go with the latter.

Typed up, the latter approach is mostly a lot of if's and for's.
Making sure the array is clean is important, and this could be placed in a separate function.

#+BEGIN_SRC C
#include <stdio.h>

#define MAXLINE 4

int cleanLine(int lim); /* getline is defined elsewhere */

/* print longest input line */
/* ^D in terminal to enter EOF. Useful: stty all  */

int main()
{
  cleanLine(MAXLINE);
  return 0;
}

int cleanLine(int lim)
{

  int blankTab[lim];
  for (int i = 0; i < lim; i++) {
    blankTab[i] = 0;
  }

  int c;
  int bti = 0; // position for blank (even) /tab (odd)

  while ((c = getchar()) != EOF) {

    if (c == '\n') {
      // remove blanks
      for (int i = 0; i < lim; i++) {
	blankTab[i] = 0;
      }
      putchar('\n');
      bti = 0;
    }
    else if (c == ' ' && bti < lim) {
      // blank so check index is even
      if (bti % 2 == 1) {
	++bti;
      }
      blankTab[bti] += 1;
    }
    else if (c == '\t' && bti < lim) {
      // tab so
      if (bti % 2 == 0) {
	++bti;
      }
      blankTab[bti] += 1;
    }
    // character case
    else {
      for (int j = 0; j < (bti + 1); j++) { // use bti to avoid searching blanksx
	if (j % 2 == 0) {
	  for (int k = 0; k < blankTab[j]; k++) {
	    putchar(' ');
	  }
	}
	else if (j % 2 == 1) {
	  for (int k = 0; k < blankTab[j]; k++) {
	    putchar('\t');
	  }
	}
	blankTab[j] = 0;
      }
      putchar(c);
      bti = 0;
    }
  }
  return 1;
}
#+END_SRC
