#+STARTUP: Overview
#+PROPERTY: header-args :noweb eval :results output
#+TITLE: K & R Exercises

* chapter 1
** 1-1

#+BEGIN_SRC C
  #include <stdio.h>

  int main()
  {
    printf("Hello, world!\n");
  }
#+END_SRC

#+RESULTS:

** 1-2

~\o~ is related to ~\0~?

** 1-3

Included in Ex. 4, though formatting other than a heading.

** 1-4

Inluced in Ex. 5

** 1-5

Straightfoward, with a few additions for testing whether constants are limited to ints (no).

#+BEGIN_SRC C
#include <stdio.h>

/*
  make a Fahrenheit-Celcuis table
 */

# define LOWER 0
# define FUPPER 212
# define FSTEP 20
# define CUPPER 100
# define CSTEP 7.532
/* No typing with symbolic constants… */

# define CLOSING_MSG "Goodbye!\n"
/*
  What's stored is determined.
  But, what about interpreting the bits?
 */


int main() {
  /* int fahr, celsius; */
  float celsius, fahr;

  printf("To begin, some fahrenheit\n");
  celsius = 0;

  /*
    No restriction on test condition. But need everything initialised.
    So, test before first instance, allowing to skip entirely.
  */
  for (fahr = FUPPER; celsius >= LOWER; fahr = fahr - FSTEP) {

    celsius = (5 * (fahr - 32)) / 9.0;
    printf("%6.2f < c ~ f > %6.2f\n", celsius, fahr);
  }

  printf("And now, for some celcuis\n");

  for (celsius = CUPPER; celsius >= LOWER; celsius = celsius - CSTEP) {
    fahr = ((celsius * 9) / 5.0) + 32;
    printf("%6.2f < c ~ f > %6.2f\n", celsius, fahr);
  }

  printf(CLOSING_MSG);
}

#+END_SRC

#+RESULTS:
#+begin_example
To begin, some fahrenheit
100.00 < c ~ f > 212.00
 88.89 < c ~ f > 192.00
 77.78 < c ~ f > 172.00
 66.67 < c ~ f > 152.00
 55.56 < c ~ f > 132.00
 44.44 < c ~ f > 112.00
 33.33 < c ~ f >  92.00
 22.22 < c ~ f >  72.00
 11.11 < c ~ f >  52.00
  0.00 < c ~ f >  32.00
-11.11 < c ~ f >  12.00
And now, for some celcuis
100.00 < c ~ f > 212.00
 92.47 < c ~ f > 198.44
 84.94 < c ~ f > 184.88
 77.40 < c ~ f > 171.33
 69.87 < c ~ f > 157.77
 62.34 < c ~ f > 144.21
 54.81 < c ~ f > 130.65
 47.28 < c ~ f > 117.10
 39.74 < c ~ f > 103.54
 32.21 < c ~ f >  89.98
 24.68 < c ~ f >  76.42
 17.15 < c ~ f >  62.87
  9.62 < c ~ f >  49.31
  2.08 < c ~ f >  35.75
Goodbye!
#+end_example

** 1-6

The parentheses aren't really required.
And, it's fine to set ~val~ as either ~char~ or ~int~ with ~%d~.
Things get messy with ~%s~.

#+BEGIN_SRC C
  #include <stdio.h>

  int val;
  char c;

  int main() {
    val = ((c = getchar()) != EOF);
    printf("%d", val);
  }
#+END_SRC

** 1-7

Extends 6 and prints things a little more elegantly.

#+BEGIN_SRC C
  #include <stdio.h>

  int val;
  char c;

  int main()
  {
   val = ((c = getchar()) != EOF);

   printf("You entered %c\n" , c);
   printf("Testing whether %c is not equal to EOF returns %d\n", c, val);

   printf("Also, if we try to print EOF the result is:\n");
   printf("%c - with c\n", EOF);
   printf("%d - with d\n", EOF);
   printf("Goodbye!\n", EOF);
   }
#+END_SRC

Sample output is

#+BEGIN_SRC C
  t
  You entered t
  Testing whether t is not equal to EOF returns 1
  Also, if we try to print EOF the result is:
  � - with c
  -1 - with d
  Goodbye!
#+END_SRC

So, there's no associated character (go figure!) and EOF is neither truthy or falsey.

** 1-8

#+BEGIN_SRC C
  #include <stdio.h>

  int main() {

    long charCount;
    int lineCount, tabCount, blankCount;
    char c;

    charCount = 0;
    lineCount = 0;
    tabCount = 0;
    blankCount = 0;

    while ((c = getchar()) != EOF) {

      if (c == '\n') {
	++lineCount;
      }
      else if (c == ' ') {
	++blankCount;
      }
      else if (c == '\t') {
	++tabCount;
      }
      else {
	++charCount;
      }
    }

    printf("The text contained:\n");
    printf("%d lines\n", lineCount);
    printf("%d tabs\n", tabCount);
    printf("%d blank characters\n", blankCount);
    printf("%ld (non-blank) characters\n", charCount);
    printf("Goodbye!\n");
  }
#+END_SRC

As multiple things are testing for each run of the loop a ~for~ construction doesn't make sense here.
Could drop brackets around all the conditions.
Could do more to format the results.

** 1-9

A little messy.
Set up a counter for number of blank chars seen, print only when this is less than 1.
Not ideal if wish to do similar things with different chars, as each other check needs to rest.

#+BEGIN_SRC C
  #include <stdio.h>

  int main() {

    long charCount;
    int lineCount, tabCount, blankCount, previousBlank, blanksLost;
    char c;

    charCount = 0;
    lineCount = 0;
    tabCount = 0;
    blankCount = 0;
    previousBlank = 0;
    blanksLost = 0;

    while ((c = getchar()) != EOF) {

      if (c == ' ') {
	++blankCount;
	++previousBlank;
      }
      else {
	if (c == '\n') {
	  ++lineCount;
	}
	else if (c == '\t') {
	  ++tabCount;
	}
	else {
	  ++charCount;
	}
	if (previousBlank > 1) {
	  blanksLost = blanksLost + (previousBlank - 1);
	}
	previousBlank = 0;
      }

      if (previousBlank < 2) {
	putchar(c);
      }
    }

    printf("The text contained:\n");
    printf("%d lines\n", lineCount);
    printf("%d tabs\n", tabCount);
    printf("%d blank characters (%d were lost)\n", blankCount, blanksLost);
    printf("%ld (non-blank) characters\n", charCount);
    printf("Goodbye!\n");
  }
#+END_SRC

** 1-10

Getting even more messy.
If a replacement is needed, signal to first output ~\~ and update ~c~ to relevant char.
Note, special case for newline, as to make things look nice, we want to both display ~\n~ and also still print a newline.

#+BEGIN_SRC C
  #include <stdio.h>

int main() {

  long charCount;
  int lineCount, tabCount, blankCount, previousBlank, blanksLost, replacement;
  char c;

  charCount = 0;
  lineCount = 0;
  tabCount = 0;
  blankCount = 0;
  previousBlank = 0;
  blanksLost = 0;
  replacement = 0;

  while ((c = getchar()) != EOF) {

    replacement = 0;

    if (c == ' ') {
      ++blankCount;
      ++previousBlank;
    }
    else {
      if (c == '\n') {
	c = 'n';
	++lineCount;
	replacement = 2; /* special case to flag newline still needed */
      }
      if (c == '\t') {
	c = 't';
	++tabCount;
	replacement = 1;
      }
      if (c == '\\') {
	replacement = 1;
      }

      if (replacement > 0) {
	putchar('\\');
      }
      else {
	++charCount;
      }
      if (previousBlank > 1) {
	blanksLost = blanksLost + (previousBlank - 1);
      }
      previousBlank = 0;
    }

    if (previousBlank < 2) {
      putchar(c);
      if (replacement == 2) {
	putchar('\n');
      }
    }
  }

  printf("The text contained:\n");
  printf("%d lines\n", lineCount);
  printf("%d tabs\n", tabCount);
  printf("%d blank characters (%d were lost)\n", blankCount, blanksLost);
  printf("%ld (non-blank) characters\n", charCount);
  printf("Goodbye!\n");
}
#+END_SRC

Backspace is difficult.

Following the above, the case would be:

#+BEGIN_SRC C
  if (c == '\b') {
    c = 'b';
    replacement = 1;
  }
#+END_SRC

However, characters are only passed on after pressing enter.
So, there's no way to pass on a backspace.

Note, this has various effects, esp. with respect to when a newline is or isn't printed.

** 1-11

Test the word count program against some texts where the count is known.
In particular, texts which include a variety of characters, esp. special characters.

For example, what happens with numbers?

Should 21 be no words, one word ('21' or 'twenty-one'), or two words (twenty one)?

Similarly, what about (3/11)?

And, what happens with something like ^B (the backspace char)?

** 1-12

Moslty a modification of word counting in the text.
Just, without the counting, and the body of empty case involving a flag.

#+BEGIN_SRC C
#include <stdio.h>

#define IN 1
#define OUT 0

int main() {

  int c, state;
  state = OUT;

  while ((c = getchar()) != EOF) {
    if (c == ' ' || c == '\t') {
      if (state == IN) {
	putchar('\n');
	state = OUT;
      }
    } else {
      state = IN;
      putchar(c);
    }
  }
}
#+END_SRC

** 1-13

Histogram in vertical orientaion.

Sample output:

#+BEGIN_SRC C
  a a a
  bb bb
  ccc ccc ccc ccc ccc
  dddd
  eeeeee eeeeee
  fffffff
  ggggggggg ggggggggg ggggggggg

	 |
	 |
   |     |                 |
   |  |  |        |        |
   |  |  |  |     |  |     |
   1  2  3  4  5  6  7  8  9
#+END_SRC

For the histogram, figure out the maximum count, then work down to 0 printing a bar whenever the count for the number is within the scope.
This uses a lot of for loops, and some things could be tidied up a little.

A highly dodgy initial version of the program is preserved a revised version.

*** prog

Note, the maximum word length is specified, and array is initialised to this length, and we only add a count to the record when the word length falls within the maximum.
The size of arrays is fixed, and things go wrong is this is forgotten about.

#+BEGIN_SRC C
#include <stdio.h>

#define IN 1
#define OUT 0
#define MAX_WL 20

  int main() {

    int i, j, c, wc, state, top_wf, top_wl;

    wc = top_wf = top_wl = 0;
    int wl[MAX_WL];
    state = OUT;

    for (i = 0; i < MAX_WL; ++i) {
      wl[i] = 0;
    }

    while ((c = getchar()) != EOF) {
      if (c == ' ' || c == '\t' || c == '\n') {
	if (state == IN) {
	  state = OUT;
	  if (wc <= MAX_WL) {
	    ++wl[wc - 1]; /* no need to count 0 */
	  }
	  wc = 0;
	}
      } else {
	state = IN;
	++wc;
      }
    }

    /* figure out max word length could
       be done while building but assume
       fewer lengths than words
    */
    for (i = 0; i < MAX_WL; ++i) {
      if (wl[i] != 0) {
	top_wl = i + 1;
	if (wl[i] > top_wf) {
	  top_wf = wl[i];
	}
      }
    }

    /* make histogram.
       go from the max length down and print
       a bar if count exceeds current
    */
    for (i = top_wf; i >= 0; --i) {
      for (j = 0; j < top_wl; ++j) {
	if (wl[j] > i) {
	  printf("  |");
	} else {
	  printf("   ");
	}
      }
      printf("\n");
    }
    /* finish off with integer */
    for (j = 0; j < top_wl; ++j) {
      printf("%3d", j + 1);
    }
    printf("\n");
  }#+END_SRC

*** bad prog

Variables named like this aren't much better than magic numbers…

I'm not sure why I thought this worked as I don't to anything to suggest the length of wl has been updated.
All I do is continue to write past the space allocated to wl and hope things work out.

#+BEGIN_SRC C
  #include <stdio.h>

  #define IN 1
  #define OUT 0

  int main() {

    int i, j, c, wc, state, old_wl, new_wl, max_wl;

    wc = max_wl = old_wl = 0;
    new_wl = 2;
    int wl[new_wl];
    state = OUT;

    for (i = old_wl; i < new_wl; ++i) {
      wl[i] = 0;
    }

    while ((c = getchar()) != EOF) {
      if (c == ' ' || c == '\t' || c == '\n') {
	if (state == IN) {
	  state = OUT;

	  if (wc >= new_wl) { /* extend the array if needed */
	    old_wl = new_wl;
	    new_wl = wc;
	    for (i = old_wl; i < new_wl; ++i) {
	      wl[i] = 0;
	    }
	  }
	  ++wl[wc - 1];
	  wc = 0;
	}
      } else {
	state = IN;
	++wc;
      }
    }

    /* figure out max word length could
       be done while building but assume
       fewer lengths than words
    ,*/
    for (i = 0; i < new_wl; ++i) {
      if (wl[i] > max_wl) {
	max_wl = wl[i];
      }
    }

    /* make histogram.
       go from the max length down and print
       a bar if count exceeds current
    ,*/
    for (i = max_wl; i >= 0; --i) {
      for (j = 0; j < new_wl; ++j) {
	if (wl[j] > i) {
	  printf(" | ");
	} else {
	  printf("   ");
	}
      }
      printf("\n");
    }
    /* finish off with integer */
    for (j = 1; j <= new_wl; ++j) {
      printf(" %d ", j);
    }
    printf("\n");
  }
#+END_SRC

** 1-14

A little easier than counting words as character choices are known beforehand.
Here, lowercase alphabetic characters are counted.
Uppercase could be added by a an additional check and further offset to obtain lowercase value.

*** sample output

#+BEGIN_SRC C
   5                          |              |
   4  |                       |              |  |           |                 |
   3  |                       |     |        |  |           |                 |
   2  |        |  |     |     |     |     |  |  |           |                 |
   1  |        |  |     |     |     |     |  |  |        |  |                 |
   0  |        |  |  |  |  |  |     |     |  |  |  |     |  |  |        |     |  |
      a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z
#+END_SRC

*** prog


#+BEGIN_SRC C
  #include <stdio.h>

  int main() {

    int i, j, c, max_wl;

    max_wl = 0;

    int wl[26];

    for (i = 0; i < 26; ++i) {
      wl[i] = 0;
    }

    while ((c = getchar()) != EOF) {
      if (c >= 'a' && c <= 'z') {
	++wl[c - 'a'];
      }
    }

    for (i = 0; i < 26; ++i) {
      if (wl[i] > max_wl) {
	max_wl = wl[i];
      }
    }

    printf("\n");
    for (i = max_wl - 1; i >= 0; --i) {
      printf(" %3d ", i);
      for (j = 0; j < 26; ++j) {
	if (wl[j] > i) {
	  printf(" | ");
	} else {
	  printf("   ");
	}
      }
      printf("\n");
    }
    printf("     ");
    for (j = 0; j < 26; ++j) {
      printf(" %c ", j + 'a');
    }
    printf("\n");
    }
#+END_SRC

** 1-15

The toFahrenheit and toCelcius functions are simple.

printTable may need some revision.
On current understanding, pass functions by pointers to function.
Explicitly passing address seems optional, same for notating converter as a pointer.

#+BEGIN_SRC C
#include <stdio.h>

/*
  make a Fahrenheit-Celcuis table using functions.
 */

# define CLOSING_MSG "Goodbye!\n"

float toFahrenheit(float celsius);
float toCelcius(float fahrenheit);
void printTable( float (*converter)(float), char[], char[], int, int, int);

int main() {
  /* int fahr, celsius; */
  printf("To begin, some fahrenheit\n");

  printTable(&toCelcius, "F", "C", 0, 212, 20);

  printf("And now, for some celcuis\n");

  printTable(&toFahrenheit, "C", "F", 0, 100, 10);

  printf(CLOSING_MSG);
}

float toFahrenheit(float celsius) { return ((celsius * 9) / 5.0) + 32; }

float toCelcius(float fahrenheit) { return (5 * (fahrenheit - 32)) / 9.0; }

void printTable(float (*converter)(float), char unitA[], char unitB[], int lower, int upper, int step) {

  for (int i = upper; i >= lower; i = i - step) {
    printf("%6.2f < %s ~ %s > %6.2f\n", (float) i, unitA, unitB, (*converter)(i));
  }
}
#+END_SRC

** 1-16

To print the length of arbitrarily long input lines we separate counting the length of a line from the copy of its (initial) characters.
A while loop runs until the line is over, and inside ~i~ counts up, and also so long as ~i~ is within the limit, the ~i~ th character is copied.

Delicate part is terminating the array.
If within the limit, \0 needs to be placed at ~i~.
Else, at the limit (it's not clear so far whether \0 is made present on initialisation).

#+BEGIN_SRC C
  #include <stdio.h>

  #define MAXLINE 10

  int getlinealt(char line[], int lim); /* getline is defined elsewhere */
  void copy(char to[], char from[]);

  /* print longest input line */
  /* ^D in terminal to enter EOF. Useful: stty all  */

  int main()
  {

    int len;
    int max = 0;
    int lineCount = 0;
    char line[MAXLINE];
    char longest[MAXLINE];

    while ((len = getlinealt(line, MAXLINE)) > 0)
      {
	lineCount += 1;
	if (len > max) {
	  max = len;
	  copy(longest, line);
	}
      }

    lineCount += 1;

    if (max > 0) {
      printf("The longest of %d lines had %d characters.\n", lineCount, max);
      printf("The longest line (up to a limit of %d characters) was:\n", (MAXLINE - 1));
      printf("%s\n", longest);
    }

    return 0;
  }

  int getlinealt(char s[], int lim)
  {
    int c;
    int i = 0;

    while ((c = getchar()) != EOF && c != '\n') {

      if (i < (lim - 1)) {
	s[i] = c;
      }
      ++i;
    }

    if (i < (lim - 1)) { // count \n char.
      if (c == '\n') {
	s[i] = c;
	++i;
      }
      s[i] = '\0';
    }
    else {
      s[lim - 1] = '\0';
    }

    return i;
  }

  void copy(char to[], char from[])
  {
    int i = 0;

    while ((to[i] = from[i]) != '\0')
      ++i;
  }
#+END_SRC

** 1-17

Printing all input lines longer than 80 characters is a quick variant to the previous.
Rather than testing for max and printing at the end, test for min and print if above limit.

#+BEGIN_SRC C
  int main()
  {
    int len;
    int min = 80;
    char line[MAXLINE];
    char longest[MAXLINE];

    while ((len = getlinealt(line, MAXLINE)) > 0)
      {
	if (len > min) {
	  copy(longest, line);
	  printf("The previous line was over %d characters.\n", min);
	  printf("Here it is (up to the first %d characters) again:\n%s\n", (MAXLINE - 1), longest);
	}
      }

    return 0;
  }
#+END_SRC

I guess these exercises are a little more interesting with a terminal that doesn't print input…

** 1-18

The issue is there may be an arbitrary number of blanks and/or tabs.

Dealing with either in isolation is simple.
'Delete' any blank/tab by default and keep a counter of how many have been deleted.
If a character (or than b/t/n) follows, 'restore' the deleted blank/tabs.

But, with b/t interleaved, things are a little more difficult.

An array can be used to store some b/t interleaving.

The order of t/b may matter too, as tabs could be used as a separator for a table, etc.
(Not that it would make much sense to delete trailing t/b in this case without some other ops.)

At the moment I don't see a way to do this generally.

The argument for this being impossible is:

Suppose possible.
Then, we have a way to recover arbitrarily large information using tools which require prespecified size and do not allow increasing such specified size.
So, there is a finite limit on the memory required to store an arbitrary amount of data.
But, that's not possible.

So, there's a trade-off.

- Store a sequence of b/t and then print regardless if run out of storage.
  - No 'inner' b/ts are lost, but trailing b/t's may be present.
- Store a sequnece of b/t and then discard if run out of storage.
  - 'Inner' b/ts may be lost, but not trailing b/ts.

The former seems more sensible, so let's go with the latter.

Typed up, the latter approach is mostly a lot of if's and for's.
Making sure the array is clean is important, and this could be placed in a separate function.

#+BEGIN_SRC C
#include <stdio.h>

#define MAXLINE 4

int cleanLine(int lim); /* getline is defined elsewhere */

/* print longest input line */
/* ^D in terminal to enter EOF. Useful: stty all  */

int main()
{
  cleanLine(MAXLINE);
  return 0;
}

int cleanLine(int lim)
{

  int blankTab[lim];
  for (int i = 0; i < lim; i++) {
    blankTab[i] = 0;
  }

  int c;
  int bti = 0; // position for blank (even) /tab (odd)

  while ((c = getchar()) != EOF) {

    if (c == '\n') {
      // remove blanks
      for (int i = 0; i < lim; i++) {
	blankTab[i] = 0;
      }
      putchar('\n');
      bti = 0;
    }
    else if (c == ' ' && bti < lim) {
      // blank so check index is even
      if (bti % 2 == 1) {
	++bti;
      }
      blankTab[bti] += 1;
    }
    else if (c == '\t' && bti < lim) {
      // tab so
      if (bti % 2 == 0) {
	++bti;
      }
      blankTab[bti] += 1;
    }
    // character case
    else {
      for (int j = 0; j < (bti + 1); j++) { // use bti to avoid searching blanksx
	if (j % 2 == 0) {
	  for (int k = 0; k < blankTab[j]; k++) {
	    putchar(' ');
	  }
	}
	else if (j % 2 == 1) {
	  for (int k = 0; k < blankTab[j]; k++) {
	    putchar('\t');
	  }
	}
	blankTab[j] = 0;
      }
      putchar(c);
      bti = 0;
    }
  }
  return 1;
}
#+END_SRC

** 1-19

*** reverse

Reverse is fairly simple.
Figure out the length of the string array.
Ignore the trailing \0.
Then, swap characters from either end moving inwards.
To do this we need a store (~swap~) for a single char and nothing else.

#+BEGIN_SRC C
  #include <stdio.h>

  int reverse(char s[]);

  int main()
  {

    char word[] = "Hello, there.";
    printf("Input:\n\t%s", word);
    reverse(word);
    printf("\nReversed:\n\t%s\n", word);

    return 0;
  }

  int reverse(char s[])
  {
    int left = 0;
    int right = 0;
    char swap;

    for (right = 0; s[right] != '\0'; right++) {}

    --right;

    while (right - left > 0) {
      swap = s[left];
      s[left] = s[right];
      s[right] = swap;
      ++left;
      --right;
    }

    return 1;
  }
#+END_SRC

*** reversing input lines

To reverse input lines we store as much of the line as possible in an array.

#+BEGIN_SRC C
int main()
{

  char c;
  char stringStore[MAXLINE];
  for (int i = 0; i < MAXLINE; i++) { stringStore[i] = '\0'; }
  int pos = 0;

  while ((c = getchar()) != EOF) {
    if (c == '\n') {
      reverse(stringStore);
      printf("%s\n", stringStore);
      for (int i = 0; i < MAXLINE; i++) {
	stringStore[i] = '\0';
      }
      pos = 0;
    }
    else {
      stringStore[pos] = c;
      ++pos;
    }
  }

  return 0;
}
#+END_SRC

** 1-20

Needed some clarification on this!

https://stackoverflow.com/questions/7178201/kr-exercise-1-20-need-some-clarification

n specifies the distance between tab stops.

So, the task is to keep track of how far the next tab stop is.

This is nice to do when reading a character at a time.
With an array, this is doable, but a little more effort.
We'd need to set a limit on the line width and then shift every character the relevant number of spaces left/right.

~main~ calls ~detab~ and ~STOPDIST~ is a symbolic constant.

#+BEGIN_SRC C
  void detab(void)
  {
    int afterTab = 0;
    char c;

    while ((c = getchar()) != EOF) {

      if (c == '\t') {
	for (int i = STOPDIST - afterTab; i > 0; i--) {
	  putchar(' ');
	}
	afterTab = 0;
      }
      else {
	putchar(c);
	if (c == '\n') {
	  afterTab = 0;
	} else {
	  afterTab = ((afterTab + 1) % STOPDIST);
	}
      }
    }
  }
#+END_SRC

** 1-21

Similar to detab.

Given anything other than a space we re-add any skipped spaces not taken up by a tab.
Then, add the char and update distance after a tabstop.

With spaces, keep a count and when a tabstop is past, add a tab and reset the counters.

#+BEGIN_SRC C
void entab(void)
{

  int spacesSeen = 0;
  int afterTab = 0;
  char c;

  while ((c = getchar()) != EOF) {

    if (c == ' ') {
      ++spacesSeen;
      if ((afterTab + spacesSeen) == STOPDIST) {
	putchar('\t');
	afterTab = 0;
	spacesSeen = 0;
      }
    }
    else {
      while (spacesSeen > 0) {
	putchar(' ');
	--spacesSeen;
	++afterTab;
      }
      putchar(c);
      ++afterTab;

      afterTab = afterTab % STOPDIST;
    }
  }
}
#+END_SRC

This was kind of difficult, if only due to thinking about tab stops and the importance of keeping track of both spaces /and/ characters.

** 1-22

These exercises seem strange.
If we're manipulating text, then surely we want a different data strucutre?

In particular some kind of linked list.

The elements of the list could be chars, though word arrays would be better.
The point being we'd like to do surgery on a small part of the input.

Here, I think the appropriate response is to read input into an array equal to line length.
Then, when this is full work out how much is safe to print.
Finally, move anything remaining to the start of the array.

Okay, on reflection this sounds like the kind of thing one would do to display text.

Stopping now before I have too much fun!

The basic idea is as above.
~lineBuffer~ stores characters to display and is processed when full.
Different cases for nice display annotated below.

Hyphenation is very basic, but I know this requires a lot of work to be nice.

Tabs are converted to a single space as I'm not sure what I want to do with these.
As a character I think it's fine to print, even if initial on row.

#+BEGIN_SRC C
  #include <stdio.h>

  #define CWIDTH 5

  int countText(char text[]);
  void fold(char input[]);
  void shiftCharsLeft(char s[], int sLength, int from, int spaces);

  int main()
  {
    char t[] = "This is a piece of text with some extrodinarily long words";
    printf("%s\n", t);
    printf("Folded to width %d:\n", CWIDTH);
    fold(t);

    return 0;
  }

  void fold(char input[])
  {

    char lineBuffer[CWIDTH];
    int bufferIndex = 0;
    int lastSpace = -1;

    int inputLength =  countText(input);

    for (int i = 0; input[i] != '\0'; i++) {

      // skip any initial spaces
      if (bufferIndex == 0 && input[i] == ' ') { ++i; }

      // copy current char and make not if empty
      if (input[i] = '\t') {
	lineBuffer[bufferIndex] = ' ';
      } else {
      lineBuffer[bufferIndex] = input[i];
      }
      if (input[i] == ' ') {
	lastSpace = bufferIndex;
      }
      ++bufferIndex;

      // when buffer is full
      if (bufferIndex == CWIDTH) {

	// if space was found
	if (lastSpace > 0) {
	  // display until spacea
	  for (int j = 0; j < lastSpace; j++) {
	    putchar(lineBuffer[j]);
	  }
	  putchar('\n');
	  // move everything after to front of buffer
	  shiftCharsLeft(lineBuffer, CWIDTH, lastSpace + 1, lastSpace + 1);
	  // point to after everything just moved for next char
	  bufferIndex = CWIDTH - (lastSpace + 1);
	  lastSpace = -1;
	}
	// if full and space or newline next ignore these.
	else if ((i + 1) < inputLength && ((input[i + 1] == ' ') || (input[i + 1] == '\n'))) {
	  for (int j = 0; j < CWIDTH; j++) {
	    putchar(lineBuffer[j]);
	  }
	  putchar('\n');
	  lastSpace = -1;
	  bufferIndex = 0;
	}
	else if ((i + 1) == inputLength) {
	  // skip as empty buffer at end
	}
	// need to break the word.
	else {
	  // print as much as possible leaving room...
	  for (int j = 0; j < (CWIDTH - 1); j++) {
	    putchar(lineBuffer[j]);
	  }
	  // for a hyphen.
	  putchar('-');
	  putchar('\n');
	  // keep leftover char
	  shiftCharsLeft(lineBuffer, CWIDTH, (CWIDTH - 1), (CWIDTH - 1));
	  bufferIndex = 1;
	  lastSpace = -1;
	}
      }
    }
    // display anything remaining in buffer
    for (int j = 0; j < CWIDTH; j++) {
      putchar(lineBuffer[j]);
    }
    putchar('\n');
  }

  int countText(char text[]) {
    int i;
    for (i = 0; text[i] != '\0'; i++) {}
    return i;
  }

  void shiftCharsLeft(char s[], int sLength, int from, int spaces)
  {
    for (int i = from; i < sLength; i++) {
      s[i - spaces] = s[i];
    }
    // cleanup
    for (int i = sLength - from; i < sLength; i++) {
      s[i] = '\0';
    }
  }
#+END_SRC


* chapter 2
** 2-1

The first approach is to use a larger type to calculate the bounds of a smaller type.
For ~char~, ~short~, ~int~, and ~long~ max, the following template works:

Note, the explicit casts to ~char~ need to be updated for ~long~, etc.
These are needed to ensure we're testing for equal representation with respect to the types of interest.

Work is done by approximation.
Start with 1 and then double this until equality fails to hold on next double.
Then, keep adding fractions of the current result until equality breaks.

The idea here for max is to approximate by addition, but to grow the amount to be added fairly fast.
And, repeat this until there's nothing more to be added without breaking equality.

Likewise for min, but with subtraction.

Float works here, but gives a different result compared to ~FLT_MAX~ and ~FLT_MIN~.
(1.67772e+07 max and +1 does nothing.)

#+BEGIN_SRC C
  #include <stdio.h>

  int main() {

    double dbl = 1;
    char max = 1;

    while ((dbl + 1) == (char) (max + 1)) {

      double j = 1;

      while (((dbl + (j * 2)) == (char) (max + (j * 2))) ) { j = j * 2; }

      dbl = dbl + j;
      max = max + j;
      }

    dbl = 1;
    char min = 1;

    while ((dbl - 1) == (char) (min - 1)) {

      double j = 1;

      while ((dbl - (j * 2)) == (char) (min - (j * 2))) { j = j * 2; }

      dbl = dbl - j;
      min = min - j;
    }

    printf("\nFinal results:\n \tMax: %d\n \tMin: %d\n", max, min);

    }
#+END_SRC

Maybe a different approach was intended, as I don't think casting has been introduced yet.
Though, this can be avoided with some 'temporary' variables, or altered tests.

** 2-2

The loop:

#+BEGIN_SRC C
  for (i=0; i<lim-1 && (c=getchar()) !=‘ヽn' && c != EOF; ++i)
    s[i] - c;
#+END_SRC

Is rewritten as:

#+BEGIN_SRC C
  char c;
  int i = 0;
  int ok = 1;

  while (ok) {
    if (i < lim-1) {
      c = getchar();
      if (c != EOF) {
	if (c != '\n') {
	  s[i] = c;
	  ++i;
	} else {
	  ok = 0;
	}
      } else {
	ok = 0;
      }
    } else {
      ok = 0;
    }
  }

  if (c == '\n') {
    s[i] = c;
    ++i;
  }
  s[i] = '\0';
  return i;
#+END_SRC

As we're effectively testing for a conjunction the var ~ok~ stores what would be the value of the conjunction.
We then work through each conjunct by an if, such that ~ok~ is set to false/0 unless the condition is satisfied.

Note, nothing depends on the order of the newline/EOF test (apart from a small increase in efficiency if the program isn't terminated at start most times) so these are switched.

** 2-3

There's nothing much to coverting a string to hex.
Assuming the input is relevantly ASCII structured, that is to help covert characters to integers.

The general idea is:

sum (16^(legnth - i) * string[i]) --- where length is the length of the string, assuming no optional 0x/0X.

- The power function used here could be redone.
- A proper warning on error would be nice.
- The use of ~j~ isn't really required as ~hexInt~ can be updated inline.


#+BEGIN_SRC C
  #include <stdio.h>
  #include <string.h>

  /* convert a string of hexadecimal digits to integer value */

  double htoi(char s[]);
  double power(double n, double m);

  int main()
  {
    char hexString[] = "854765aa";
    htoi(hexString);

    printf("%f\n", htoi("854765aa"));
    printf("%f\n", htoi("0x854765aa"));
    printf("%f\n", htoi("0X854765aa"));
    return 0;
  }

  double htoi(char s[])
  {
    double hexInt = 0;

    unsigned long hexLength = strlen(s);
    unsigned long i = 0;

    double hexExp = hexLength - 1;

    // adjust start and initial exponent if optional 0x/0X
    if (s[0] == '0' && (s[1] == 'x' || s[1] == 'X')) {
      i = 2;
      hexExp -= 2;
    }

    // covert char to int and then raise to relevant exponent
    for ( ; i < hexLength; i++) {
      char c = s[i];
      int j = 0;
      if (c >= '0' && c <= '9') {
	j = c - '0';
      }
      else if (c >='a' && c <= 'f') {
	j = c - 'a' + 10;
      }
      else if (c >='A' && c <= 'F') {
	j = c - 'A' + 10;
      }
      else {
	printf("error, not a valid hex number");
      }
      hexInt += power(16, hexExp) * j;
      --hexExp;
    }
    return hexInt;
  }

  /* basic power func */
  double power(double n, double m)
  {
    if (m == 0) {
      return 1;
    }
    else {
      double base = n;
      for (int i = 1; i < m; i++) {
	base *= n;
      }
      return base;
    }
  }
  
#+END_SRC

** 2-4

Nothing to interesting here, the only addition is a func to return whether a char is in a string.

This could be made much more efficient by sorting the lookup string or doing mostly anything other than a loop checking for identity.

~found~ is uneeded as every instance could be replaced with ~c == d~.
However, this requires making the comparison each time and makes things a little harder to read.

#+BEGIN_SRC C
  #include <stdio.h>

  void squeezeChar(char s[], int c);
  void squeezeString(char s[], char t[]);
  int containsStringChar(char s[], char c);

  int main()
  {
    char str1[] = "programming";
    char str2[] = "programming";

    squeezeChar(str1, 'r');
    squeezeString(str2, "rp");

    printf("%s\n", str1);
    printf("%s\n", str2);

    squeezeString(str2, str2);

    printf("%s\n", str2);

    return 0;
  }

  /* squeezeChar: delete all c from s */
  void squeezeChar(char s[], int c)
  {
    int i, j;

    for (i = j = 0; s[i] != '\0'; i++)
      if (s[i] != c)
	s[j++] = s[i];
    s[j] = '\0';
  }


  void squeezeString(char s[], char t[])
  {
    int i, j;

    for (i = j = 0; s[i] != '\0'; i++)
      if (!containsStringChar(t, s[i]))
	s[j++] = s[i];
    s[j] = '\0';
  }


  int containsStringChar(char s[], char c)
  {
    int i = 0;
    char d;
    int found = 0;
    while ((d = s[i]) != '\0' && found != 1) {
      if (d == c)
	found = 1;
      ++i;
    }
    return found;
  }
#+END_SRC

** 2-5

Using ~containsStringChar~ as above, check each char and break the loop as soon as something is found.

To get the last location, remove this.

Could return j + 1 if US indexing.

#+BEGIN_SRC C
  int any(char s[], char t[])
  {
    int j = -1;

    for (int i = 0; s[i] != '\0' && j == -1; i++)
      if (containsStringChar(t, s[i]))
	j = i;
    return j;
  }
#+END_SRC

** 2-6

This took some learning, so things are worked out in full.

#+BEGIN_SRC C
  unsigned setbits(unsigned x, int p, int n, unsigned y)
  {
    unsigned rightmostYMask = ~((~0 >> n) << n);
    unsigned rightmostNofY = rightmostYMask & y;
    unsigned rightmostNofYatP = rightmostNofY << (p - n);
    unsigned XwithoutP = (x >> p) << p;
    unsigned XwithNfromY = XwithoutP | rightmostNofYatP;
    unsigned leftoverPMask = ~(~0 >> (p - n) << (p - n));
    unsigned leftoverP = x & leftoverPMask;
    unsigned replacement = XwithNfromY | leftoverP;

    return replacement;
  }
#+END_SRC

- ~rightmostYMask~
  - Take however many 1s, move left and right by n to have n 0s at the end.
    Then, invert to get 0s and then n 1s at the end.
- ~rightmostNofY~
  - and previous with y.
- ~rightmostNofYatP~
  - shift previous left p minus n spaces, as we already have n bits.
- ~XwithoutP~
  - move x left and right p to set the rightmost p bits to 0.
- ~XwithNfromY~
  - Now have the first ?? bits of n and then 0s.
    So, or this with the bits from y shifted over, and we get n bits from y in position p.
    Final task is to restore any leftover bits from x.
- ~leftoverPMask~, ~leftoverP~
  - Same idea as ~rightmostYMask~ and ~rightmostNofY~.
- ~replacement~
  - In full: ~~XwithoutP | rightmostNofYatP | leftoverP~.

** 2-7

Inverting can be seen as a special case of replacement where the replacement bits come from taking the complement of the initial.

So, this is the approach taken.

~replaceBits~ is a simple variant of ~setbits~, where we shift the initial y mask to get bits from p rather than the rightmost bits.

#+BEGIN_SRC C
  /* like setbits, but instead of the rightmost n of y, take n from y at p
 key difference is first mask, which now shifts back to position. */
unsigned replaceBits(unsigned x, int p, int n, unsigned y)
{
  unsigned YMask1 = ~((~0 >> n) << p);
  unsigned YMask2 = ((~0 >> n) << (p - n));
  unsigned YMask = YMask1 & YMask2;
  unsigned rightmostNofYatP = YMask & y;
  unsigned XwithoutP = (x >> p) << p;
  unsigned XwithNfromY = XwithoutP | rightmostNofYatP;
  unsigned leftoverPMask = ~(~0 >> (p - n) << (p - n));
  unsigned leftoverP = x & leftoverPMask;
  unsigned replacement = XwithNfromY | leftoverP;

  return replacement;
}

/* to invert n bits from p replace n bits from p with complement */
unsigned invert(unsigned x, int p, int n)
{
  return replaceBits(x, p, n, ~x);
}
#+END_SRC

** 2-8

A little harder than expected.
Though, things fell into place when I realised ~(faster)Bitcount~ could be used to figure out how many bits there are to work with.

Here's the quick function:

#+BEGIN_SRC C
  int possibleBitcount()
  {
    return fasterBitcount(~0);
  }
#+END_SRC

I.e., could the total bits when all possible bits are set to 1!

Now, to rotate everything right:

#+BEGIN_SRC C
  unsigned rotright(unsigned x, int n)
  {
    int totalBits = possibleBitcount();
    int reducedN = n % totalBits;
    unsigned newLeft = x << (totalBits - reducedN);
    unsigned newRightMask = ~((~0 >> (totalBits - reducedN)) << (totalBits - reducedN));
    unsigned newRight = (x >> reducedN) & newRightMask;
    unsigned newBits = newLeft | newRight;

    return newBits;
  }
#+END_SRC

** 2-9

Huh, this is cool.

So, while x, b++, x &= (x - 1).
So long as there's a 1 bit x will pass a not-false.

This works as for positive and negative integers:

- If odd, then rightmost bit is 1.
- If even, then rightmost bit is 0.
- And:
  - Subtracting 1 requires every bit from (and including) the rightmost 1 bit to be flipped from 0 to 1.

Typed up:

#+BEGIN_SRC C
  int fasterBitcount(unsigned x)
  {
    int b = 0;

    while (x) {
      x &= (x - 1);
      b++;
    }
    return b;
  }
#+END_SRC

** 2-10

#+BEGIN_SRC C
  int altLower(int c)
  {
    return (c >= 'A' && c <= 'Z') ? c + 'a' - 'A' : c;
  }
#+END_SRC


* chapter 3

** 3-1

Keep going until there's no difference between low and high, then check to see whether this is a match…

#+BEGIN_SRC C
  int altBinsearch(int x, int v[], int n)
  {
    int low, high, mid;

    low = 0;
    high = n - 1;

    while (low <= high) {
      mid = (low + high) / 2;
      if (x < v[mid])
	high = mid - 1;
      else
	low = mid + 1;

      if (v[mid] == x)/* found match */
	return mid;
    }
    return -1; /* no match */
  }
#+END_SRC

** 3-2

There's nothing too interesting here.
As chars are ints it's easy to switch on the percieved content of a char.
Need two separate pointers to elems of the arrays as may need to add an extra character (~escape~) or remove an extra character (~unescape~).

Most of the time was tracking down a bug due to writing ~s[j] = t[j]~ in the else clause of ~unescape~.

#+BEGIN_SRC C
  void escape(char s[], char t[])
  {
    int i = 0;
    int j = 0;

    while (t[i] != '\0') {

      switch (t[i]) {
      case '\t':
	s[j] = '\\';
	++j;
	s[j] = 't';
	break;
      case '\n':
	s[j] = '\\';
	++j;
	s[j] = 'n';
	break;
      default:
	s[j] = t[i];
      }
      ++j;
      ++i;
    }
    s[j] = '\0';
  }

#+END_SRC

#+BEGIN_SRC C
  void unescape(char s[], char t[])
  {
    int i = 0;
    int j = 0;

    while (t[i] != '\0') {
      if (t[i] == '\\') {
	switch (t[i + 1]) {
	case 't':
	  s[j] = '\t';
	  ++i;
	  break;
	case 'n':
	  s[j] = '\n';
	  ++i;
	  break;
	default:
	  s[j] = t[j];
	}
	++i;
	++j;
      } else {
	s[j] = t[i];
	++i;
	++j;
      }
    }
    s[j] = '\0';
  }
#+END_SRC

** 3-3

To help out, a test to see whether two characters allow for replacement.

#+BEGIN_SRC C
  int twoAlphOrNum(char a, char b)
  {
    if (('a' <= a && a <= 'z') && ('a' <= b && b <= 'z'))
      return 1;
    else if (('A' <= a && a <= 'Z') && ('A' <= b && b <= 'Z'))
      return 1;
    else if (('0' <= a && a <= '9') && ('0' <= b && a <= '9'))
      return 1;
    return 0;
  }
#+END_SRC

~expand~ works through ~s1~ and when a ~-~ is found tests the characters either side with ~twoAlphOrNum~.
The first and last characters are handled separately in order to ensure it's always safe to test either side of ~-~.

There's a check to ensure something like ~a-a~ is expanded to ~a~, and otherwise a for loop expands everything as required.

We assume ~s2~ is known to have enough space.

~twoAlphOrNum~ can be changed to allow different expansions (e.g. ~0-b~, etc.).

#+BEGIN_SRC C
void expand(char s1[], char s2[])
{
  int s1i = 0;
  int s2i = 0;

  // copy first and last outside of loop
  // length doesn't matter, as at worst this is \0.
  s2[s2i] = s1[s1i];
  ++s1i;
  ++s2i;

  for (int j = strlen(s1) - 1; s1i < j; s1i++) {
    printf("s1i: %d, char: %c\n", s1i, s1[s1i]);
    // know before and after are safe to check
    if (s1[s1i] == '-' && twoAlphOrNum(s1[s1i - 1], s1[s1i + 1])) {
      if (s1[s1i - 1] == s1[s1i + 1]) {
	++s1i;
      } else {
	for (int k = s1[s1i - 1] + 1; k < s1[s1i + 1]; k++, s2i++) {
	  s2[s2i] = k;
	}
      }
    }
    else {
      s2[s2i] = s1[s1i];
      ++s2i;
    }
  }

  s2[s2i] = s1[s1i];
  ++s1i;
  ++s2i;
  s2[s2i] = '\0';
}
#+END_SRC

** 3-4

The problem is there's no way to represent -n when n = -(2^(wordsize-1)).
This is due to 0 being positive.
So, max negative = max positive + 1.

To fix this, we can take the bit complement of a negative number and 'manually' add one.

This results in a special first case, so the do… while… is rewritten to special case… (regular) while…

The special case is just like the reguar case expect for negative adjustment is made to record an extra one.
As we still need to be careful of the (bit) size of n, this means ~(n /= 10)~ is repeated in all cases.

#+BEGIN_SRC C
  void itoaPlus(int n, char s[])
  {
    int i, sign;
    if ((sign = n) < 0)
      n = ~n;
    i = 0;

    if (sign < 0) {
      if (n % 10 < 9) {
	s[i++] = n % 10 + '1';
	(n /= 10);
      } else {
	s[i++] = '0';
	(n /= 10);
	++n;
      }
    } else {
      s[i++] = n % 10 + '0';
      (n /= 10);
    }

    while (n > 0) {
      s[i++] = n % 10 + '0';
      (n /= 10);
    }

    if (sign < 0)
      s[i++] = '-';
    s[i] = '\0';
    reverse(s);
  }
#+END_SRC

Note, the initial version had a mistake where ~(n /= 10)~ was part of the while test and a missing ~(n /= 10)~ from the positive first case.
This led to an additional division for negative numbers.

** 3-5

~itob~ is basically the same as ~itoa~.
The only difference is a choice of base and a little more work to figure out the character to print.
The approach taken works so long as the base is less than 37.
I'd need to lookup notation for larger bases.
Though, this should be easy to extend…

Note, given previous observations ~getChar((n % b) + 1)~ is required in the first lookup, as ~getChar((n + 1) % b)~ might make n too large.

#+BEGIN_SRC C
  int getChar(int n)
  {
    if (n < 10) {
      return n + '0';
    } else {
      return (n - 10) + 'a';
    }
  }
#+END_SRC

#+BEGIN_SRC C
  void itob(int n, char s[], int b)
  {
    int i, sign;
    if ((sign = n) < 0)
      n = ~n;
    i = 0;

    if (sign < 0) {
      if ((n % b) < (b - 1)) {
	s[i++] = getChar((n % b) + 1);
	(n /= b);
      } else {
	s[i++] = '0';
	(n /= b);
	++n;
      }
    } else {
      s[i++] = getChar(n % b);
      (n /= b);
    }

    while (n > 0) {
      s[i++] = getChar(n % b);
      (n /= b);
    }

    if (sign < 0)
      s[i++] = '-';
    s[i] = '\0';
    reverse(s);
  }
#+END_SRC

** 3-6

Simple approach is to count down ~w~ whenever a character is added and then add the remianing number of blanks at the end.
~itob~ is modified as ~itoa~ is just a special case.

#+BEGIN_SRC C
  void itobW(int n, char s[], int b, int w)
  {
    int i, sign;
    if ((sign = n) < 0)
      n = ~n;
    i = 0;

    if (sign < 0) {
      if ((n % b) < (b - 1)) {
	s[i++] = getChar((n % b) + 1);
	--w;
	(n /= b);
      } else {
	s[i++] = '0';
	--w;
	(n /= b);
	++n;
      }
    } else {
      s[i++] = getChar(n % b);
      --w;
      (n /= b);
    }

    while (n > 0) {
      s[i++] = getChar(n % b);
      --w;
      (n /= b);
    }

    if (sign < 0) {
      s[i++] = '-';
      --w;
    }
    for (; w > 0; w--, i++) {
      s[i] = ' ';
    }
    s[i] = '\0';
    reverse(s);
  }
#+END_SRC


* chapter 4

** 4-1

To get the right index keep searching through the line and update some variable (here ~lastIndex~) whenever a match is found.

#+BEGIN_SRC C
  int rstrindex(char s[], char t[])
  {
    int i, j, k;
    int lastIndex = -1;

    for (i = 0; s[i] != '\0'; i++) {
      for (j=i, k=0; t[k]!='\0' &s[j]==t[k]; j++, k++)
	;
      if (k > 0 &t[k] == '\0')
	lastIndex = i;
    }
    return lastIndex;
  }
#+END_SRC

** 4-2

Basic idea is to treat any exponentiation as another number.
Use sign to work out whether to up ~val~ or ~power~.

~pw~ is same basic power function from above, renamed as power is already in use.

This could be more elegant.
As, if ~atoi~ took a positional argument the first calculation of ~e~ could be passed off and then used as an exponent on return.


#+BEGIN_SRC C
  double atof(char s[])
  {
    double val, power;
    int i, sign;
    int pluse;
    double e;

    for (i = 0; isspace(s[i]); i++)  /* skip white space */
      ;

    sign = (s[i] == '-') ? -1 : 1;

    if (s[i] == '+' || s[i] == '-')
      i++;

    for (val = 0.0; isdigit(s[i]); i++)
      val = 10.0 * val + (s[i] - '0');

    if (s[i] == '.')
	     i++;

    for (power = 1.0; isdigit(s[i]); i++) {
      val = 10.0 * val + (s[i] - '0');
      power *= 10;
    }

    if (s[i] == 'e' || s[i] == 'E') {
      ++i;
      pluse = (s[i] == '-') ? 0 : 1;
      if (s[i] == '+' || s[i] == '-')
	i++;
      for (e = 0; isdigit(s[i]); i++)
	e = 10 * e + (s[i] - '0');
      e = pw(10, e);
      if (pluse) {
	val *= e;
      } else {
	power *= e;
      }
    }

    return sign * val / power;
  }
#+END_SRC

** 4-3

*** mod

modulus is an additional case.

Here, we do things 'by hand' as ~%~ requires ~int~ args.

#+BEGIN_SRC C
  case '%':
  op2 = pop();
  op1 = pop();
  while (op1 > op2) {
    op1 -= op2;
  }
  push(op1);
  break;
#+END_SRC

An alterantive is to downcast the doubles to ints:

#+BEGIN_SRC C
  case '%':
  op2 = pop();
  push(((int) pop() % (int) op2));
  break;
#+END_SRC

*** negative numbers

For negative numbers we only need to make sure any sign is included in the call to ~atoi~.

The following small changes do not work:

#+BEGIN_SRC C
  if (!isdigit(c) && c != '.' && c != '-' && c != '+') /* &&s added */
#+END_SRC

#+BEGIN_SRC C
  if (isdigit(c) || c == '-' || c == '+')    /* ||s added */
#+END_SRC

The issue is + and - are now seen as parts of an number rather than operators.

To fix this, a small check is made at the end of ~getop~ (but after the possible call to ~ungetch~):

#+BEGIN_SRC C
  if (s > 0 && !isdigit(s[i - 1])) {
    return s[i - 1];
  }
#+END_SRC

This checks no integer part was found.
If so, the operator is returned.

With this change we need to ensure ~s~ isn't used for anything else so it's fine to leave the op in ~s~, and it is.

**** fix

The following /works/ but is not right:

#+BEGIN_SRC C
  if (isdigit(c) || c != '-' || c != '+')    /* ||s added */
#+END_SRC

The idea here is we've already recorded the first non-b/t character so we'd like to continue if there's a sign or we have a digit.

~c != '-' || c != '+'~ covers any character, so of course we'll continue…

** 4-4

*** print top

To print the top (two) elements we use '?'.

#+BEGIN_SRC C
  case '?': /* print top two elements, though top is popped if \n is required for input to be processed */
  if (sp == 0)
    printf("The stack is empty\n");
  if (sp > 0)
    printf("Top:\t%g\n", val[sp - 1]);
  if (sp > 1)
    printf("Below:\t%g\n", val[sp - 2]);
  break;
#+END_SRC

These don't do anything fancy to allow inspecting the stack during a calculation.
E.g.:

#+BEGIN_SRC C
1 3 ? + 5 4 * ? +
Top:	3
Below:	1
Top:	20
Below:	4
	24
#+END_SRC

*** duplication

push the top of the stack…

#+BEGIN_SRC C
  case 'd':
  push(val[sp - 1]);
  break;
#+END_SRC

squaring is nice with this (~%n d *~)

*** swap

An interesting desgin choice.
One option is to use ~push~ to store the swap value on the stack.
However, this only works when the stack has space.

A different option is to Gödel encode both numbers to one, swap and then decode.

Or, just use a swap variable…

#+BEGIN_SRC C
  case 's':
  swap = val[sp - 1];
  val[sp - 1] = val[sp - 2];
  val[sp - 2] = swap;
  break;
#+END_SRC

*** clearing

Reset the stack pointer.
There's no need to clean the stack as there's no option to search through the stack.

#+BEGIN_SRC C
  case 'c':
  sp = 0;
  break;
#+END_SRC

** 4-5

This is a puzzling exercise.
Adding library functions is easy (e.g. ~exp~ below).

However, these need to be reduced to a character to be added easily.
Or, better put, things get complex if an attempt is made to use strings to identify operators.

It's easy to convert the core of ~getop~ to a test on whether or not a string represents a number.

The difficulty is dispatch.
This is a switch statement, and switch statements require integers.
So, there are two options:

1. Create an internal character name for each string.
2. Rewrite the dispatch.

Neither option is compelling.
(1) seems very bad pratice, but (2) then requires either:
a. Passing around strings.
b. An external op string seen by all.

An external op string is very much in the spirit of the text.
But, we then /still/ need to work in testing string equality.

This all seems a lot for the Ex.
And, looking at the next ex it seems a switch dispatch is still assumed.

So…

*** exp

#+BEGIN_SRC C
  case 'e':
  push(exp(pop()));
  break;
#+END_SRC

** 4-6

Handling variables is a bit of a headache (may be by design?)

At the global level there's an array to store the variable values and a pointer to the most recently accessed variable.

Every time a variable is seen it is accessed.

Assigning variables is handled by ~n v =~.
Where ~n~ is the value and ~v~ is the variable.

~v~ is evaluated, so the variable pointer is updated, and this can be used to set the value in the variable array to ~n~.

This means variables always have a value.
The could be avoided by setting up a flag for whether a variable has been seen.
But, that would require an additional array.

Varibles are from ~v~ to ~z~ (so five in total).

To the main switch we add:

#+BEGIN_SRC C
  case VARIABLE:
  vp = s[0] - 'v';
  push(vars[vp]);
  break;
#+END_SRC

And:

#+BEGIN_SRC C
  case '=':
  pop(); // ignore variable value
  vars[vp] = pop();
  push(vars[vp]); // evalute var immediately
  break;
#+END_SRC

To ~getop~ we update the ~return c~ check:

#+BEGIN_SRC C
  if (!isdigit(c) && c != '.' && c != '-' && c != '+') {
      if ('v' < c && c <= 'z')
	return VARIABLE;
      else if (c == 'l')
	return LAST;
      return c;      /* not a number */
   }
#+END_SRC

~l~ is a special variable, always set to the most recent pop:

#+BEGIN_SRC C
  double pop(void)
  {
    if (sp > 0) {
      vars[5] = val[--sp];
      return vars[5];
    }
    else {
      printf("error: stack empty\n");
      return 0.0;
    }
  }
#+END_SRC

Note, this doesn't update the variable pointer.

This is all fairly hacky.
And, at the moment it's possible to type in a sequence of varaibles (e.g. ~xvvz~).

This can be fixed, of course.
Though, rewriting ~getop~ and dispatch seem preferable.
In particular, it seems ~getop~ should be broken into getting an expression (delimited by however many spaces) and then testing this to see whether it's a number, variable, op, or special command (print, etc).
Then this can be passed to the relevant dispatch.

Some other time…

** 4-7

The following basically places ~ungetch~ in a loop over the characters in the string.

#+BEGIN_SRC C
  void ungets(char s[])   /* push string back on input */
  {
    for (int i = 0; s[i] != '\0'; i++) {
      if (bufp >= BUFSIZE)
	printf("ungets: too many characters\n");
      else
	buf[bufp++] = s[i];
    }
  }
#+END_SRC

This is roughly the same as:

#+BEGIN_SRC C
  void ungets(char s[])   /* push string back on input */
  {
    for (int i = 0; s[i] != '\0'; i++)
      ungetch(s[i]);
  }
#+END_SRC

The only benift as things stand is a custom error message.

The choice requires more context, I think.

If ~ungets~ should mirror the action of ~ungetch~ then calling ~ungetch~ seems preferable, as any change to ~ungetch~ will pass through to ~ungets~.

Otherwise, leave the parallel coincidental.

One consideration is checking whether the length of the string fits before thinking about ~ungetch~.
One could then avoid partially filling the buffer.

Though, there's no clear motivation to do this, and would amount to more ops.

** 4-8

If there's only one possible character of pushback:

1. Set ~BUFSIZE~ to ~1~.
2. Everything else is optional.

Optionally:

a. The ~bufp~ tests can simply test ~bufp~.
   The pointer is either ~0~ or ~1~.
b. ~bufp~ can be set directly to ~0~ or ~1~.
   For, there's only one possible decrement/increment value.
c. Replace ~buf~ with a single variable.
   ~bufp~ is still used to check whether to use the value of the variable, though.
   (Unless some impossible value for the char is known in advance. So, could use EOF.)

** 4-9

Is the pointer here that EOF is not a character?

So, ~buf~ either needs to allow for ints or some other mechanism needs to be used?

From S1.5.1:

#+BEGIN_QUOTE
This value is called EOF, for "end of file." We must declare c to be a type big enough to hold any value that getchar returns. We can't use char since c must be big enough to hold EOF in addition to any possible char. Therefore we use int.
#+END_QUOTE

This seems the way to go, as ~getchar~ returns ~int~, as def'd in B1.
So, while EOF may be the focus here, the change to ~buf~ ensures anything written to ~buf~ is preserved.

*** the change

#+BEGIN_SRC C
  int buf[BUFSIZE];    /* buffer for ungetch */
#+END_SRC

*** alternative

I don't see a good alternative.

If the goal is to allow EOF pushback, then we'd need some way of storing ~BUFSIZE~ EOFs.

We could also ignore EOFs.
This keep in line with the description of ~getch~ and ~ungetch~ (which originally only mentions characters).

E.g.:

#+BEGIN_SRC C
  void ungetch(int c)   /* push result of getchar back on input */
  {
    if (bufp >= BUFSIZE)
      printf("ungetch: too many characters\n");
    else
      if (c != EOF)
	buf[bufp++] = c;
  }
#+END_SRC

** 4-10

Each line may contain multiple numbers, operators, etc separated by spaces.
So, using ~getline~ requires splitting the line into parts to be processed by ~getop~.

The basic cycle could be:

1. ~main~ calls ~getop~.
2. ~getop~ calls ~gettoken~.
3. ~gettoken~ returns the next token in the string (inlc. EOF).
4. ~getop~ calls ~parsetoken~ which classifies the token and returns to ~main~.

The issue is tokens.
Specifically ~atof~, as this taken a string argumnet.

This requirement suggests ~gettoken~ should copy the token to a string rather than retuning indicies of whether the token begins and ends on the line.

Copying things over seems conceptually the way to go.
For, ~main~ then only needs to know about the next token.

Given how small things are and a desire to keep ~main~ unchanged, the addition of ~gettoken~ and ~parsetoken~ isn't really worth it.

Instead, ~getop~ behaves almost exactly as before, but by walking through the string.

For flexibility, ~getop~ calls either ~getopbystr~ (new) or ~getopbych~ (the old ~getop~):


#+BEGIN_SRC C
  int getop(char s[])
  {
    int getopbystr(char s[]);
    return getopbystr(s);

    /* int getopbych(char s[]); */
    /* return getopbych(s); */
  }
#+END_SRC

The helper function for copying strings is ~copyab~.

#+BEGIN_SRC C
  /* copy: copies 'from' between (inlc.) a and b into 'to'.
     assumes to is big enough */
  void copyab(char to[], char from[], int a, int b)
  {
    int i = 0;

    while (a < b) {
      to[i++] = from[a++];
    }
    to[i] = '\0';
  }
#+END_SRC

~getopbystr~ uses ~getline~ (from the book) and ~copyab~.
The only difference is moving the ~lp~ pointer in contrast to getting a character.

Note, ~line~ and ~lp~ are defined outside ~getopbystr~ to ensure these persist when part of the string is evaluated by ~main~.

#+BEGIN_SRC C
  /* outside of function for persistence */
char line[MAXOP]; /* line buffer */
int lp = 0; /* line pointer, ++lp is unparsed */


int getopbystr(char s[])
{
  int getlinealt(char s[], int lim);
  void copyab(char to[], char from[], int a, int b);

  if (line[lp] == '\0') {
    getlinealt(line, MAXOP);
    lp = 0;
  }

  while (line[lp] == ' ' || line[lp] == '\t')
    lp++; // point smth after b/t

  if (!isdigit(line[lp]) &&
      line[lp] != '.' &&
      line[lp] != '-' &&
      line[lp] != '+') {
    copyab(s, line, lp, lp + 1);
    ++lp;
    if ('v' < line[lp - 1] && line[lp - 1] <= 'z') {
      return VARIABLE;
    }
    else if (line[lp - 1] == 'l') {
      return LAST;
    }
    return line[lp - 1]; /* not a number */
  }

  int i = lp + 1; /* always capture next symbol */

  /* if digit, gather */
  while (isdigit(line[i])) {
    ++i;
  }

  /* collect fraction part if present */
  if (line[i + 1] == '.') {
    ++i;
    while (isdigit(line[i + 1]))
      ++i;
  }

  /* update s
   this could be skipped if not digit, but then need to consider lp update
   and contrast to getopbych */
  copyab(s, line, lp, i);
  /* update unprocessed */
  lp = i;

  if (!isdigit(line[i - 1])) {
    return line[i - 1];
  }
  else {
    return NUMBER;
  }
}
#+END_SRC

The headache here was mapping between original transformations to ~s~ and updates to ~lp~.
The clearest difference is increments to ~i~ (used to extend ~sp~) happen after testing.

Deciding on the behaviour of ~copyab~ (whether inclusive or exclusive wrt. to ~b~) was also a bit of a headache.
Some things work nicely inclusive (getting a single char without incrementing), but others not so much (having ~lp~ point to somethiing inparsed).

