#+STARTUP: Overview
#+PROPERTY: header-args :noweb eval :results output
#+TITLE: K&R Exercises

* chapter 1
** 1-1

#+BEGIN_SRC C
  #include <stdio.h>

  int main()
  {
    printf("Hello, world!\n");
  }
#+END_SRC

** 1-2

~\o~ is related to ~\0~?

** 1-3

Included in Ex. 4, though formatting other than a heading.

** 1-4

Induced in Ex. 5

** 1-5

Straightforward, with a few additions for testing whether constants are limited to ints (no).

#+BEGIN_SRC C
#include <stdio.h>

/*
  make a Fahrenheit-Celcuis table
 */

# define LOWER 0
# define FUPPER 212
# define FSTEP 20
# define CUPPER 100
# define CSTEP 7.532
/* No typing with symbolic constants… */

# define CLOSING_MSG "Goodbye!\n"
/*
  What's stored is determined.
  But, what about interpreting the bits?
 */


int main() {
  /* int fahr, celsius; */
  float celsius, fahr;

  printf("To begin, some fahrenheit\n");
  celsius = 0;

  /*
    No restriction on test condition. But need everything initialised.
    So, test before first instance, allowing to skip entirely.
  */
  for (fahr = FUPPER; celsius >= LOWER; fahr = fahr - FSTEP) {

    celsius = (5 * (fahr - 32)) / 9.0;
    printf("%6.2f < c ~ f > %6.2f\n", celsius, fahr);
  }

  printf("And now, for some celcuis\n");

  for (celsius = CUPPER; celsius >= LOWER; celsius = celsius - CSTEP) {
    fahr = ((celsius * 9) / 5.0) + 32;
    printf("%6.2f < c ~ f > %6.2f\n", celsius, fahr);
  }

  printf(CLOSING_MSG);
}

#+END_SRC

#+RESULTS:
#+begin_example
To begin, some fahrenheit
100.00 < c ~ f > 212.00
 88.89 < c ~ f > 192.00
 77.78 < c ~ f > 172.00
 66.67 < c ~ f > 152.00
 55.56 < c ~ f > 132.00
 44.44 < c ~ f > 112.00
 33.33 < c ~ f >  92.00
 22.22 < c ~ f >  72.00
 11.11 < c ~ f >  52.00
  0.00 < c ~ f >  32.00
-11.11 < c ~ f >  12.00
And now, for some celcuis
100.00 < c ~ f > 212.00
 92.47 < c ~ f > 198.44
 84.94 < c ~ f > 184.88
 77.40 < c ~ f > 171.33
 69.87 < c ~ f > 157.77
 62.34 < c ~ f > 144.21
 54.81 < c ~ f > 130.65
 47.28 < c ~ f > 117.10
 39.74 < c ~ f > 103.54
 32.21 < c ~ f >  89.98
 24.68 < c ~ f >  76.42
 17.15 < c ~ f >  62.87
  9.62 < c ~ f >  49.31
  2.08 < c ~ f >  35.75
Goodbye!
#+end_example

** 1-6

The parentheses aren't really required.
And, it's fine to set ~val~ as either ~char~ or ~int~ with ~%d~.
Things get messy with ~%s~.

#+BEGIN_SRC C
  #include <stdio.h>

  int val;
  char c;

  int main() {
    val = ((c = getchar()) != EOF);
    printf("%d", val);
  }
#+END_SRC

** 1-7

Extends 6 and prints things a little more elegantly.

#+BEGIN_SRC C
  #include <stdio.h>

  int val;
  char c;

  int main()
  {
   val = ((c = getchar()) != EOF);

   printf("You entered %c\n" , c);
   printf("Testing whether %c is not equal to EOF returns %d\n", c, val);

   printf("Also, if we try to print EOF the result is:\n");
   printf("%c - with c\n", EOF);
   printf("%d - with d\n", EOF);
   printf("Goodbye!\n", EOF);
   }
#+END_SRC

Sample output is

#+BEGIN_SRC C
  t
  You entered t
  Testing whether t is not equal to EOF returns 1
  Also, if we try to print EOF the result is:
  � - with c
  -1 - with d
  Goodbye!
#+END_SRC

So, there's no associated character (go figure!) and EOF is neither truthy or falsey.

** 1-8

#+BEGIN_SRC C
  #include <stdio.h>

  int main() {

    long charCount;
    int lineCount, tabCount, blankCount;
    char c;

    charCount = 0;
    lineCount = 0;
    tabCount = 0;
    blankCount = 0;

    while ((c = getchar()) != EOF) {

      if (c == '\n') {
	++lineCount;
      }
      else if (c == ' ') {
	++blankCount;
      }
      else if (c == '\t') {
	++tabCount;
      }
      else {
	++charCount;
      }
    }

    printf("The text contained:\n");
    printf("%d lines\n", lineCount);
    printf("%d tabs\n", tabCount);
    printf("%d blank characters\n", blankCount);
    printf("%ld (non-blank) characters\n", charCount);
    printf("Goodbye!\n");
  }
#+END_SRC

As multiple things are testing for each run of the loop a ~for~ construction doesn't make sense here.
Could drop brackets around all the conditions.
Could do more to format the results.

** 1-9

A little messy.
Set up a counter for number of blank chars seen, print only when this is less than 1.
Not ideal if wish to do similar things with different chars, as each other check needs to rest.

#+BEGIN_SRC C
  #include <stdio.h>

  int main() {

    long charCount;
    int lineCount, tabCount, blankCount, previousBlank, blanksLost;
    char c;

    charCount = 0;
    lineCount = 0;
    tabCount = 0;
    blankCount = 0;
    previousBlank = 0;
    blanksLost = 0;

    while ((c = getchar()) != EOF) {

      if (c == ' ') {
	++blankCount;
	++previousBlank;
      }
      else {
	if (c == '\n') {
	  ++lineCount;
	}
	else if (c == '\t') {
	  ++tabCount;
	}
	else {
	  ++charCount;
	}
	if (previousBlank > 1) {
	  blanksLost = blanksLost + (previousBlank - 1);
	}
	previousBlank = 0;
      }

      if (previousBlank < 2) {
	putchar(c);
      }
    }

    printf("The text contained:\n");
    printf("%d lines\n", lineCount);
    printf("%d tabs\n", tabCount);
    printf("%d blank characters (%d were lost)\n", blankCount, blanksLost);
    printf("%ld (non-blank) characters\n", charCount);
    printf("Goodbye!\n");
  }
#+END_SRC

** 1-10

Getting even more messy.
If a replacement is needed, signal to first output ~\~ and update ~c~ to relevant char.
Note, special case for newline, as to make things look nice, we want to both display ~\n~ and also still print a newline.

#+BEGIN_SRC C
  #include <stdio.h>

int main() {

  long charCount;
  int lineCount, tabCount, blankCount, previousBlank, blanksLost, replacement;
  char c;

  charCount = 0;
  lineCount = 0;
  tabCount = 0;
  blankCount = 0;
  previousBlank = 0;
  blanksLost = 0;
  replacement = 0;

  while ((c = getchar()) != EOF) {

    replacement = 0;

    if (c == ' ') {
      ++blankCount;
      ++previousBlank;
    }
    else {
      if (c == '\n') {
	c = 'n';
	++lineCount;
	replacement = 2; /* special case to flag newline still needed */
      }
      if (c == '\t') {
	c = 't';
	++tabCount;
	replacement = 1;
      }
      if (c == '\\') {
	replacement = 1;
      }

      if (replacement > 0) {
	putchar('\\');
      }
      else {
	++charCount;
      }
      if (previousBlank > 1) {
	blanksLost = blanksLost + (previousBlank - 1);
      }
      previousBlank = 0;
    }

    if (previousBlank < 2) {
      putchar(c);
      if (replacement == 2) {
	putchar('\n');
      }
    }
  }

  printf("The text contained:\n");
  printf("%d lines\n", lineCount);
  printf("%d tabs\n", tabCount);
  printf("%d blank characters (%d were lost)\n", blankCount, blanksLost);
  printf("%ld (non-blank) characters\n", charCount);
  printf("Goodbye!\n");
}
#+END_SRC

Backspace is difficult.

Following the above, the case would be:

#+BEGIN_SRC C
  if (c == '\b') {
    c = 'b';
    replacement = 1;
  }
#+END_SRC

However, characters are only passed on after pressing enter.
So, there's no way to pass on a backspace.

Note, this has various effects, esp. with respect to when a newline is or isn't printed.

** 1-11

Test the word count program against some texts where the count is known.
In particular, texts which include a variety of characters, esp. special characters.

For example, what happens with numbers?

Should 21 be no words, one word ('21' or 'twenty-one'), or two words (twenty one)?

Similarly, what about (3/11)?

And, what happens with something like ^B (the backspace char)?

** 1-12

Mostly a modification of word counting in the text.
Just, without the counting, and the body of empty case involving a flag.

#+BEGIN_SRC C
#include <stdio.h>

#define IN 1
#define OUT 0

int main() {

  int c, state;
  state = OUT;

  while ((c = getchar()) != EOF) {
    if (c == ' ' || c == '\t') {
      if (state == IN) {
	putchar('\n');
	state = OUT;
      }
    } else {
      state = IN;
      putchar(c);
    }
  }
}
#+END_SRC

** 1-13

Histogram in vertical orientation.

Sample output:

#+BEGIN_SRC C
  a a a
  bb bb
  ccc ccc ccc ccc ccc
  dddd
  eeeeee eeeeee
  fffffff
  ggggggggg ggggggggg ggggggggg

	 |
	 |
   |     |                 |
   |  |  |        |        |
   |  |  |  |     |  |     |
   1  2  3  4  5  6  7  8  9
#+END_SRC

For the histogram, figure out the maximum count, then work down to 0 printing a bar whenever the count for the number is within the scope.
This uses a lot of for loops, and some things could be tidied up a little.

A highly dodgy initial version of the program is preserved a revised version.

*** prog

Note, the maximum word length is specified, and array is initialised to this length, and we only add a count to the record when the word length falls within the maximum.
The size of arrays is fixed, and things go wrong is this is forgotten about.

#+BEGIN_SRC C
#include <stdio.h>

#define IN 1
#define OUT 0
#define MAX_WL 20

  int main() {

    int i, j, c, wc, state, top_wf, top_wl;

    wc = top_wf = top_wl = 0;
    int wl[MAX_WL];
    state = OUT;

    for (i = 0; i < MAX_WL; ++i) {
      wl[i] = 0;
    }

    while ((c = getchar()) != EOF) {
      if (c == ' ' || c == '\t' || c == '\n') {
	if (state == IN) {
	  state = OUT;
	  if (wc <= MAX_WL) {
	    ++wl[wc - 1]; /* no need to count 0 */
	  }
	  wc = 0;
	}
      } else {
	state = IN;
	++wc;
      }
    }

    /* figure out max word length could
       be done while building but assume
       fewer lengths than words
    */
    for (i = 0; i < MAX_WL; ++i) {
      if (wl[i] != 0) {
	top_wl = i + 1;
	if (wl[i] > top_wf) {
	  top_wf = wl[i];
	}
      }
    }

    /* make histogram.
       go from the max length down and print
       a bar if count exceeds current
    */
    for (i = top_wf; i >= 0; --i) {
      for (j = 0; j < top_wl; ++j) {
	if (wl[j] > i) {
	  printf("  |");
	} else {
	  printf("   ");
	}
      }
      printf("\n");
    }
    /* finish off with integer */
    for (j = 0; j < top_wl; ++j) {
      printf("%3d", j + 1);
    }
    printf("\n");
  }#+END_SRC

*** bad prog

Variables named like this aren't much better than magic numbers…

I'm not sure why I thought this worked as I don't to anything to suggest the length of wl has been updated.
All I do is continue to write past the space allocated to wl and hope things work out.

#+BEGIN_SRC C
  #include <stdio.h>

  #define IN 1
  #define OUT 0

  int main() {

    int i, j, c, wc, state, old_wl, new_wl, max_wl;

    wc = max_wl = old_wl = 0;
    new_wl = 2;
    int wl[new_wl];
    state = OUT;

    for (i = old_wl; i < new_wl; ++i) {
      wl[i] = 0;
    }

    while ((c = getchar()) != EOF) {
      if (c == ' ' || c == '\t' || c == '\n') {
	if (state == IN) {
	  state = OUT;

	  if (wc >= new_wl) { /* extend the array if needed */
	    old_wl = new_wl;
	    new_wl = wc;
	    for (i = old_wl; i < new_wl; ++i) {
	      wl[i] = 0;
	    }
	  }
	  ++wl[wc - 1];
	  wc = 0;
	}
      } else {
	state = IN;
	++wc;
      }
    }

    /* figure out max word length could
       be done while building but assume
       fewer lengths than words
    ,*/
    for (i = 0; i < new_wl; ++i) {
      if (wl[i] > max_wl) {
	max_wl = wl[i];
      }
    }

    /* make histogram.
       go from the max length down and print
       a bar if count exceeds current
    ,*/
    for (i = max_wl; i >= 0; --i) {
      for (j = 0; j < new_wl; ++j) {
	if (wl[j] > i) {
	  printf(" | ");
	} else {
	  printf("   ");
	}
      }
      printf("\n");
    }
    /* finish off with integer */
    for (j = 1; j <= new_wl; ++j) {
      printf(" %d ", j);
    }
    printf("\n");
  }
#+END_SRC

** 1-14

A little easier than counting words as character choices are known beforehand.
Here, lowercase alphabetic characters are counted.
Uppercase could be added by a an additional check and further offset to obtain lowercase value.

*** sample output

#+BEGIN_SRC C
   5                          |              |
   4  |                       |              |  |           |                 |
   3  |                       |     |        |  |           |                 |
   2  |        |  |     |     |     |     |  |  |           |                 |
   1  |        |  |     |     |     |     |  |  |        |  |                 |
   0  |        |  |  |  |  |  |     |     |  |  |  |     |  |  |        |     |  |
      a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z
#+END_SRC

*** prog


#+BEGIN_SRC C
  #include <stdio.h>

  int main() {

    int i, j, c, max_wl;

    max_wl = 0;

    int wl[26];

    for (i = 0; i < 26; ++i) {
      wl[i] = 0;
    }

    while ((c = getchar()) != EOF) {
      if (c >= 'a' && c <= 'z') {
	++wl[c - 'a'];
      }
    }

    for (i = 0; i < 26; ++i) {
      if (wl[i] > max_wl) {
	max_wl = wl[i];
      }
    }

    printf("\n");
    for (i = max_wl - 1; i >= 0; --i) {
      printf(" %3d ", i);
      for (j = 0; j < 26; ++j) {
	if (wl[j] > i) {
	  printf(" | ");
	} else {
	  printf("   ");
	}
      }
      printf("\n");
    }
    printf("     ");
    for (j = 0; j < 26; ++j) {
      printf(" %c ", j + 'a');
    }
    printf("\n");
    }
#+END_SRC

** 1-15

The toFahrenheit and toCelcius functions are simple.

printTable may need some revision.
On current understanding, pass functions by pointers to function.
Explicitly passing address seems optional, same for notating converter as a pointer.

#+BEGIN_SRC C
#include <stdio.h>

/*
  make a Fahrenheit-Celcuis table using functions.
 */

# define CLOSING_MSG "Goodbye!\n"

float toFahrenheit(float celsius);
float toCelcius(float fahrenheit);
void printTable( float (*converter)(float), char[], char[], int, int, int);

int main() {
  /* int fahr, celsius; */
  printf("To begin, some fahrenheit\n");

  printTable(&toCelcius, "F", "C", 0, 212, 20);

  printf("And now, for some celcuis\n");

  printTable(&toFahrenheit, "C", "F", 0, 100, 10);

  printf(CLOSING_MSG);
}

float toFahrenheit(float celsius) { return ((celsius * 9) / 5.0) + 32; }

float toCelcius(float fahrenheit) { return (5 * (fahrenheit - 32)) / 9.0; }

void printTable(float (*converter)(float), char unitA[], char unitB[], int lower, int upper, int step) {

  for (int i = upper; i >= lower; i = i - step) {
    printf("%6.2f < %s ~ %s > %6.2f\n", (float) i, unitA, unitB, (*converter)(i));
  }
}
#+END_SRC

** 1-16

To print the length of arbitrarily long input lines we separate counting the length of a line from the copy of its (initial) characters.
A while loop runs until the line is over, and inside ~i~ counts up, and also so long as ~i~ is within the limit, the ~i~ th character is copied.

Delicate part is terminating the array.
If within the limit, \0 needs to be placed at ~i~.
Else, at the limit (it's not clear so far whether \0 is made present on initialisation).

#+BEGIN_SRC C
  #include <stdio.h>

  #define MAXLINE 10

  int getlinealt(char line[], int lim); /* getline is defined elsewhere */
  void copy(char to[], char from[]);

  /* print longest input line */
  /* ^D in terminal to enter EOF. Useful: stty all  */

  int main()
  {

    int len;
    int max = 0;
    int lineCount = 0;
    char line[MAXLINE];
    char longest[MAXLINE];

    while ((len = getlinealt(line, MAXLINE)) > 0)
      {
	lineCount += 1;
	if (len > max) {
	  max = len;
	  copy(longest, line);
	}
      }

    lineCount += 1;

    if (max > 0) {
      printf("The longest of %d lines had %d characters.\n", lineCount, max);
      printf("The longest line (up to a limit of %d characters) was:\n", (MAXLINE - 1));
      printf("%s\n", longest);
    }

    return 0;
  }

  int getlinealt(char s[], int lim)
  {
    int c;
    int i = 0;

    while ((c = getchar()) != EOF && c != '\n') {

      if (i < (lim - 1)) {
	s[i] = c;
      }
      ++i;
    }

    if (i < (lim - 1)) { // count \n char.
      if (c == '\n') {
	s[i] = c;
	++i;
      }
      s[i] = '\0';
    }
    else {
      s[lim - 1] = '\0';
    }

    return i;
  }

  void copy(char to[], char from[])
  {
    int i = 0;

    while ((to[i] = from[i]) != '\0')
      ++i;
  }
#+END_SRC

** 1-17

Printing all input lines longer than 80 characters is a quick variant to the previous.
Rather than testing for max and printing at the end, test for min and print if above limit.

#+BEGIN_SRC C
  int main()
  {
    int len;
    int min = 80;
    char line[MAXLINE];
    char longest[MAXLINE];

    while ((len = getlinealt(line, MAXLINE)) > 0)
      {
	if (len > min) {
	  copy(longest, line);
	  printf("The previous line was over %d characters.\n", min);
	  printf("Here it is (up to the first %d characters) again:\n%s\n", (MAXLINE - 1), longest);
	}
      }

    return 0;
  }
#+END_SRC

I guess these exercises are a little more interesting with a terminal that doesn't print input…

** 1-18

The issue is there may be an arbitrary number of blanks and/or tabs.

Dealing with either in isolation is simple.
'Delete' any blank/tab by default and keep a counter of how many have been deleted.
If a character (or than b/t/n) follows, 'restore' the deleted blank/tabs.

But, with b/t interleaved, things are a little more difficult.

An array can be used to store some b/t interleaving.

The order of t/b may matter too, as tabs could be used as a separator for a table, etc.
(Not that it would make much sense to delete trailing t/b in this case without some other ops.)

At the moment I don't see a way to do this generally.

The argument for this being impossible is:

Suppose possible.
Then, we have a way to recover arbitrarily large information using tools which require pre-specified size and do not allow increasing such specified size.
So, there is a finite limit on the memory required to store an arbitrary amount of data.
But, that's not possible.

So, there's a trade-off.

- Store a sequence of b/t and then print regardless if run out of storage.
  - No 'inner' b/ts are lost, but trailing b/t's may be present.
- Store a sequence of b/t and then discard if run out of storage.
  - 'Inner' b/ts may be lost, but not trailing b/ts.

The former seems more sensible, so let's go with the latter.

Typed up, the latter approach is mostly a lot of if's and for's.
Making sure the array is clean is important, and this could be placed in a separate function.

#+BEGIN_SRC C
#include <stdio.h>

#define MAXLINE 4

int cleanLine(int lim); /* getline is defined elsewhere */

/* print longest input line */
/* ^D in terminal to enter EOF. Useful: stty all  */

int main()
{
  cleanLine(MAXLINE);
  return 0;
}

int cleanLine(int lim)
{

  int blankTab[lim];
  for (int i = 0; i < lim; i++) {
    blankTab[i] = 0;
  }

  int c;
  int bti = 0; // position for blank (even) /tab (odd)

  while ((c = getchar()) != EOF) {

    if (c == '\n') {
      // remove blanks
      for (int i = 0; i < lim; i++) {
	blankTab[i] = 0;
      }
      putchar('\n');
      bti = 0;
    }
    else if (c == ' ' && bti < lim) {
      // blank so check index is even
      if (bti % 2 == 1) {
	++bti;
      }
      blankTab[bti] += 1;
    }
    else if (c == '\t' && bti < lim) {
      // tab so
      if (bti % 2 == 0) {
	++bti;
      }
      blankTab[bti] += 1;
    }
    // character case
    else {
      for (int j = 0; j < (bti + 1); j++) { // use bti to avoid searching blanksx
	if (j % 2 == 0) {
	  for (int k = 0; k < blankTab[j]; k++) {
	    putchar(' ');
	  }
	}
	else if (j % 2 == 1) {
	  for (int k = 0; k < blankTab[j]; k++) {
	    putchar('\t');
	  }
	}
	blankTab[j] = 0;
      }
      putchar(c);
      bti = 0;
    }
  }
  return 1;
}
#+END_SRC

** 1-19

*** reverse

Reverse is fairly simple.
Figure out the length of the string array.
Ignore the trailing \0.
Then, swap characters from either end moving inwards.
To do this we need a store (~swap~) for a single char and nothing else.

#+BEGIN_SRC C
  #include <stdio.h>

  int reverse(char s[]);

  int main()
  {

    char word[] = "Hello, there.";
    printf("Input:\n\t%s", word);
    reverse(word);
    printf("\nReversed:\n\t%s\n", word);

    return 0;
  }

  int reverse(char s[])
  {
    int left = 0;
    int right = 0;
    char swap;

    for (right = 0; s[right] != '\0'; right++) {}

    --right;

    while (right - left > 0) {
      swap = s[left];
      s[left] = s[right];
      s[right] = swap;
      ++left;
      --right;
    }

    return 1;
  }
#+END_SRC

*** reversing input lines

To reverse input lines we store as much of the line as possible in an array.

#+BEGIN_SRC C
int main()
{

  char c;
  char stringStore[MAXLINE];
  for (int i = 0; i < MAXLINE; i++) { stringStore[i] = '\0'; }
  int pos = 0;

  while ((c = getchar()) != EOF) {
    if (c == '\n') {
      reverse(stringStore);
      printf("%s\n", stringStore);
      for (int i = 0; i < MAXLINE; i++) {
	stringStore[i] = '\0';
      }
      pos = 0;
    }
    else {
      stringStore[pos] = c;
      ++pos;
    }
  }

  return 0;
}
#+END_SRC

** 1-20

Needed some clarification on this!

https://stackoverflow.com/questions/7178201/kr-exercise-1-20-need-some-clarification

n specifies the distance between tab stops.

So, the task is to keep track of how far the next tab stop is.

This is nice to do when reading a character at a time.
With an array, this is doable, but a little more effort.
We'd need to set a limit on the line width and then shift every character the relevant number of spaces left/right.

~main~ calls ~detab~ and ~STOPDIST~ is a symbolic constant.

#+BEGIN_SRC C
  void detab(void)
  {
    int afterTab = 0;
    char c;

    while ((c = getchar()) != EOF) {

      if (c == '\t') {
	for (int i = STOPDIST - afterTab; i > 0; i--) {
	  putchar(' ');
	}
	afterTab = 0;
      }
      else {
	putchar(c);
	if (c == '\n') {
	  afterTab = 0;
	} else {
	  afterTab = ((afterTab + 1) % STOPDIST);
	}
      }
    }
  }
#+END_SRC

** 1-21

Similar to detab.

Given anything other than a space we re-add any skipped spaces not taken up by a tab.
Then, add the char and update distance after a tabstop.

With spaces, keep a count and when a tabstop is past, add a tab and reset the counters.

#+BEGIN_SRC C
  void entab(void)
  {
    int spacesSeen = 0;
    int afterTab = 0;
    char c;

    while ((c = getchar()) != EOF) {

      if (c == ' ') {
	++spacesSeen;
	if ((afterTab + spacesSeen) == STOPDIST) {
	  putchar('\t');
	  afterTab = 0;
	  spacesSeen = 0;
	}
      }
      else {
	while (spacesSeen > 0) {
	  putchar(' ');
	  --spacesSeen;
	  afterTab = ((afterTab + 1) % STOPDIST);
	}
	putchar(c);
	afterTab = ((afterTab + 1) % STOPDIST);
      }
    }
  }
#+END_SRC

This was kind of difficult, if only due to thinking about tab stops and the importance of keeping track of both spaces /and/ characters.

** 1-22

These exercises seem strange.
If we're manipulating text, then surely we want a different data strucutre?

In particular some kind of linked list.

The elements of the list could be chars, though word arrays would be better.
The point being we'd like to do surgery on a small part of the input.

Here, I think the appropriate response is to read input into an array equal to line length.
Then, when this is full work out how much is safe to print.
Finally, move anything remaining to the start of the array.

Okay, on reflection this sounds like the kind of thing one would do to display text.

Stopping now before I have too much fun!

The basic idea is as above.
~lineBuffer~ stores characters to display and is processed when full.
Different cases for nice display annotated below.

Hyphenation is very basic, but I know this requires a lot of work to be nice.

Tabs are converted to a single space as I'm not sure what I want to do with these.
As a character I think it's fine to print, even if initial on row.

#+BEGIN_SRC C
  #include <stdio.h>

  #define CWIDTH 5

  int countText(char text[]);
  void fold(char input[]);
  void shiftCharsLeft(char s[], int sLength, int from, int spaces);

  int main()
  {
    char t[] = "This is a piece of text with some extrodinarily long words";
    printf("%s\n", t);
    printf("Folded to width %d:\n", CWIDTH);
    fold(t);

    return 0;
  }

  void fold(char input[])
  {

    char lineBuffer[CWIDTH];
    int bufferIndex = 0;
    int lastSpace = -1;

    int inputLength =  countText(input);

    for (int i = 0; input[i] != '\0'; i++) {

      // skip any initial spaces
      if (bufferIndex == 0 && input[i] == ' ') { ++i; }

      // copy current char and make not if empty
      if (input[i] = '\t') {
	lineBuffer[bufferIndex] = ' ';
      } else {
      lineBuffer[bufferIndex] = input[i];
      }
      if (input[i] == ' ') {
	lastSpace = bufferIndex;
      }
      ++bufferIndex;

      // when buffer is full
      if (bufferIndex == CWIDTH) {

	// if space was found
	if (lastSpace > 0) {
	  // display until spacea
	  for (int j = 0; j < lastSpace; j++) {
	    putchar(lineBuffer[j]);
	  }
	  putchar('\n');
	  // move everything after to front of buffer
	  shiftCharsLeft(lineBuffer, CWIDTH, lastSpace + 1, lastSpace + 1);
	  // point to after everything just moved for next char
	  bufferIndex = CWIDTH - (lastSpace + 1);
	  lastSpace = -1;
	}
	// if full and space or newline next ignore these.
	else if ((i + 1) < inputLength && ((input[i + 1] == ' ') || (input[i + 1] == '\n'))) {
	  for (int j = 0; j < CWIDTH; j++) {
	    putchar(lineBuffer[j]);
	  }
	  putchar('\n');
	  lastSpace = -1;
	  bufferIndex = 0;
	}
	else if ((i + 1) == inputLength) {
	  // skip as empty buffer at end
	}
	// need to break the word.
	else {
	  // print as much as possible leaving room...
	  for (int j = 0; j < (CWIDTH - 1); j++) {
	    putchar(lineBuffer[j]);
	  }
	  // for a hyphen.
	  putchar('-');
	  putchar('\n');
	  // keep leftover char
	  shiftCharsLeft(lineBuffer, CWIDTH, (CWIDTH - 1), (CWIDTH - 1));
	  bufferIndex = 1;
	  lastSpace = -1;
	}
      }
    }
    // display anything remaining in buffer
    for (int j = 0; j < CWIDTH; j++) {
      putchar(lineBuffer[j]);
    }
    putchar('\n');
  }

  int countText(char text[]) {
    int i;
    for (i = 0; text[i] != '\0'; i++) {}
    return i;
  }

  void shiftCharsLeft(char s[], int sLength, int from, int spaces)
  {
    for (int i = from; i < sLength; i++) {
      s[i - spaces] = s[i];
    }
    // cleanup
    for (int i = sLength - from; i < sLength; i++) {
      s[i] = '\0';
    }
  }
#+END_SRC


* chapter 2
** 2-1

The first approach is to use a larger type to calculate the bounds of a smaller type.
For ~char~, ~short~, ~int~, and ~long~ max, the following template works:

Note, the explicit casts to ~char~ need to be updated for ~long~, etc.
These are needed to ensure we're testing for equal representation with respect to the types of interest.

Work is done by approximation.
Start with 1 and then double this until equality fails to hold on next double.
Then, keep adding fractions of the current result until equality breaks.

The idea here for max is to approximate by addition, but to grow the amount to be added fairly fast.
And, repeat this until there's nothing more to be added without breaking equality.

Likewise for min, but with subtraction.

Float works here, but gives a different result compared to ~FLT_MAX~ and ~FLT_MIN~.
(1.67772e+07 max and +1 does nothing.)

#+BEGIN_SRC C
  #include <stdio.h>

  int main() {

    double dbl = 1;
    char max = 1;

    while ((dbl + 1) == (char) (max + 1)) {

      double j = 1;

      while (((dbl + (j * 2)) == (char) (max + (j * 2))) ) { j = j * 2; }

      dbl = dbl + j;
      max = max + j;
      }

    dbl = 1;
    char min = 1;

    while ((dbl - 1) == (char) (min - 1)) {

      double j = 1;

      while ((dbl - (j * 2)) == (char) (min - (j * 2))) { j = j * 2; }

      dbl = dbl - j;
      min = min - j;
    }

    printf("\nFinal results:\n \tMax: %d\n \tMin: %d\n", max, min);

    }
#+END_SRC

Maybe a different approach was intended, as I don't think casting has been introduced yet.
Though, this can be avoided with some 'temporary' variables, or altered tests.

** 2-2

The loop:

#+BEGIN_SRC C
  for (i=0; i<lim-1 && (c=getchar()) !=‘ヽn' && c != EOF; ++i)
    s[i] - c;
#+END_SRC

Is rewritten as:

#+BEGIN_SRC C
  char c;
  int i = 0;
  int ok = 1;

  while (ok) {
    if (i < lim-1) {
      c = getchar();
      if (c != EOF) {
	if (c != '\n') {
	  s[i] = c;
	  ++i;
	} else {
	  ok = 0;
	}
      } else {
	ok = 0;
      }
    } else {
      ok = 0;
    }
  }

  if (c == '\n') {
    s[i] = c;
    ++i;
  }
  s[i] = '\0';
  return i;
#+END_SRC

As we're effectively testing for a conjunction the var ~ok~ stores what would be the value of the conjunction.
We then work through each conjunct by an if, such that ~ok~ is set to false/0 unless the condition is satisfied.

Note, nothing depends on the order of the newline/EOF test (apart from a small increase in efficiency if the program isn't terminated at start most times) so these are switched.

** 2-3

There's nothing much to converting a string to hex.
Assuming the input is relevantly ASCII structured, that is to help covert characters to integers.

The general idea is:

sum (16^(length - i) * string[i]) --- where length is the length of the string, assuming no optional 0x/0X.

- The power function used here could be redone.
- A proper warning on error would be nice.
- The use of ~j~ isn't really required as ~hexInt~ can be updated inline.


#+BEGIN_SRC C
  #include <stdio.h>
  #include <string.h>

  /* convert a string of hexadecimal digits to integer value */

  double htoi(char s[]);
  double power(double n, double m);

  int main()
  {
    char hexString[] = "854765aa";
    htoi(hexString);

    printf("%f\n", htoi("854765aa"));
    printf("%f\n", htoi("0x854765aa"));
    printf("%f\n", htoi("0X854765aa"));
    return 0;
  }

  double htoi(char s[])
  {
    double hexInt = 0;

    unsigned long hexLength = strlen(s);
    unsigned long i = 0;

    double hexExp = hexLength - 1;

    // adjust start and initial exponent if optional 0x/0X
    if (s[0] == '0' && (s[1] == 'x' || s[1] == 'X')) {
      i = 2;
      hexExp -= 2;
    }

    // covert char to int and then raise to relevant exponent
    for ( ; i < hexLength; i++) {
      char c = s[i];
      int j = 0;
      if (c >= '0' && c <= '9') {
	j = c - '0';
      }
      else if (c >='a' && c <= 'f') {
	j = c - 'a' + 10;
      }
      else if (c >='A' && c <= 'F') {
	j = c - 'A' + 10;
      }
      else {
	printf("error, not a valid hex number");
      }
      hexInt += power(16, hexExp) * j;
      --hexExp;
    }
    return hexInt;
  }

  /* basic power func */
  double power(double n, double m)
  {
    if (m == 0) {
      return 1;
    }
    else {
      double base = n;
      for (int i = 1; i < m; i++) {
	base *= n;
      }
      return base;
    }
  }
#+END_SRC

** 2-4

Nothing to interesting here, the only addition is a func to return whether a char is in a string.

This could be made much more efficient by sorting the lookup string or doing mostly anything other than a loop checking for identity.

~found~ is unneeded as every instance could be replaced with ~c == d~.
However, this requires making the comparison each time and makes things a little harder to read.

#+BEGIN_SRC C
  #include <stdio.h>

  void squeezeChar(char s[], int c);
  void squeezeString(char s[], char t[]);
  int containsStringChar(char s[], char c);

  int main()
  {
    char str1[] = "programming";
    char str2[] = "programming";

    squeezeChar(str1, 'r');
    squeezeString(str2, "rp");

    printf("%s\n", str1);
    printf("%s\n", str2);

    squeezeString(str2, str2);

    printf("%s\n", str2);

    return 0;
  }

  /* squeezeChar: delete all c from s */
  void squeezeChar(char s[], int c)
  {
    int i, j;

    for (i = j = 0; s[i] != '\0'; i++)
      if (s[i] != c)
	s[j++] = s[i];
    s[j] = '\0';
  }


  void squeezeString(char s[], char t[])
  {
    int i, j;

    for (i = j = 0; s[i] != '\0'; i++)
      if (!containsStringChar(t, s[i]))
	s[j++] = s[i];
    s[j] = '\0';
  }


  int containsStringChar(char s[], char c)
  {
    int i = 0;
    char d;
    int found = 0;
    while ((d = s[i]) != '\0' && found != 1) {
      if (d == c)
	found = 1;
      ++i;
    }
    return found;
  }
#+END_SRC

** 2-5

Using ~containsStringChar~ as above, check each char and break the loop as soon as something is found.

To get the last location, remove this.

Could return j + 1 if US indexing.

#+BEGIN_SRC C
  int any(char s[], char t[])
  {
    int j = -1;

    for (int i = 0; s[i] != '\0' && j == -1; i++)
      if (containsStringChar(t, s[i]))
	j = i;
    return j;
  }
#+END_SRC

** 2-6

This took some learning, so things are worked out in full.

#+BEGIN_SRC C
  unsigned setbits(unsigned x, int p, int n, unsigned y)
  {
    unsigned rightmostYMask = ~((~0 >> n) << n);
    unsigned rightmostNofY = rightmostYMask & y;
    unsigned rightmostNofYatP = rightmostNofY << (p - n);
    unsigned XwithoutP = (x >> p) << p;
    unsigned XwithNfromY = XwithoutP | rightmostNofYatP;
    unsigned leftoverPMask = ~(~0 >> (p - n) << (p - n));
    unsigned leftoverP = x & leftoverPMask;
    unsigned replacement = XwithNfromY | leftoverP;

    return replacement;
  }
#+END_SRC

- ~rightmostYMask~
  - Take however many 1s, move left and right by n to have n 0s at the end.
    Then, invert to get 0s and then n 1s at the end.
- ~rightmostNofY~
  - and previous with y.
- ~rightmostNofYatP~
  - shift previous left p minus n spaces, as we already have n bits.
- ~XwithoutP~
  - move x left and right p to set the rightmost p bits to 0.
- ~XwithNfromY~
  - Now have the first ?? bits of n and then 0s.
    So, or this with the bits from y shifted over, and we get n bits from y in position p.
    Final task is to restore any leftover bits from x.
- ~leftoverPMask~, ~leftoverP~
  - Same idea as ~rightmostYMask~ and ~rightmostNofY~.
- ~replacement~
  - In full: ~~XwithoutP | rightmostNofYatP | leftoverP~.

** 2-7

Inverting can be seen as a special case of replacement where the replacement bits come from taking the complement of the initial.

So, this is the approach taken.

~replaceBits~ is a simple variant of ~setbits~, where we shift the initial y mask to get bits from p rather than the rightmost bits.

#+BEGIN_SRC C
  /* like setbits, but instead of the rightmost n of y, take n from y at p
 key difference is first mask, which now shifts back to position. */
unsigned replaceBits(unsigned x, int p, int n, unsigned y)
{
  unsigned YMask1 = ~((~0 >> n) << p);
  unsigned YMask2 = ((~0 >> n) << (p - n));
  unsigned YMask = YMask1 & YMask2;
  unsigned rightmostNofYatP = YMask & y;
  unsigned XwithoutP = (x >> p) << p;
  unsigned XwithNfromY = XwithoutP | rightmostNofYatP;
  unsigned leftoverPMask = ~(~0 >> (p - n) << (p - n));
  unsigned leftoverP = x & leftoverPMask;
  unsigned replacement = XwithNfromY | leftoverP;

  return replacement;
}

/* to invert n bits from p replace n bits from p with complement */
unsigned invert(unsigned x, int p, int n)
{
  return replaceBits(x, p, n, ~x);
}
#+END_SRC

** 2-8

A little harder than expected.
Though, things fell into place when I realised ~(faster)Bitcount~ could be used to figure out how many bits there are to work with.

Here's the quick function:

#+BEGIN_SRC C
  int possibleBitcount()
  {
    return fasterBitcount(~0);
  }
#+END_SRC

I.e., could the total bits when all possible bits are set to 1!

Now, to rotate everything right:

#+BEGIN_SRC C
  unsigned rotright(unsigned x, int n)
  {
    int totalBits = possibleBitcount();
    int reducedN = n % totalBits;
    unsigned newLeft = x << (totalBits - reducedN);
    unsigned newRightMask = ~((~0 >> (totalBits - reducedN)) << (totalBits - reducedN));
    unsigned newRight = (x >> reducedN) & newRightMask;
    unsigned newBits = newLeft | newRight;

    return newBits;
  }
#+END_SRC

** 2-9

Huh, this is cool.

So, while x, b++, x &= (x - 1).
So long as there's a 1 bit x will pass a not-false.

This works as for positive and negative integers:

- If odd, then rightmost bit is 1.
- If even, then rightmost bit is 0.
- And:
  - Subtracting 1 requires every bit from (and including) the rightmost 1 bit to be flipped from 0 to 1.

Typed up:

#+BEGIN_SRC C
  int fasterBitcount(unsigned x)
  {
    int b = 0;

    while (x) {
      x &= (x - 1);
      b++;
    }
    return b;
  }
#+END_SRC

** 2-10

#+BEGIN_SRC C
  int altLower(int c)
  {
    return (c >= 'A' && c <= 'Z') ? c + 'a' - 'A' : c;
  }
#+END_SRC


* chapter 3
** 3-1

Keep going until there's no difference between low and high, then check to see whether this is a match…

#+BEGIN_SRC C
  int altBinsearch(int x, int v[], int n)
  {
    int low, high, mid;

    low = 0;
    high = n - 1;

    while (low <= high) {
      mid = (low + high) / 2;
      if (x < v[mid])
	high = mid - 1;
      else
	low = mid + 1;

      if (v[mid] == x)/* found match */
	return mid;
    }
    return -1; /* no match */
  }
#+END_SRC

** 3-2

There's nothing too interesting here.
As chars are ints it's easy to switch on the perceived content of a char.
Need two separate pointers to elems of the arrays as may need to add an extra character (~escape~) or remove an extra character (~unescape~).

Most of the time was tracking down a bug due to writing ~s[j] = t[j]~ in the else clause of ~unescape~.

#+BEGIN_SRC C
  void escape(char s[], char t[])
  {
    int i = 0;
    int j = 0;

    while (t[i] != '\0') {

      switch (t[i]) {
      case '\t':
	s[j] = '\\';
	++j;
	s[j] = 't';
	break;
      case '\n':
	s[j] = '\\';
	++j;
	s[j] = 'n';
	break;
      default:
	s[j] = t[i];
      }
      ++j;
      ++i;
    }
    s[j] = '\0';
  }

#+END_SRC

#+BEGIN_SRC C
  void unescape(char s[], char t[])
  {
    int i = 0;
    int j = 0;

    while (t[i] != '\0') {
      if (t[i] == '\\') {
	switch (t[i + 1]) {
	case 't':
	  s[j] = '\t';
	  ++i;
	  break;
	case 'n':
	  s[j] = '\n';
	  ++i;
	  break;
	default:
	  s[j] = t[j];
	}
	++i;
	++j;
      } else {
	s[j] = t[i];
	++i;
	++j;
      }
    }
    s[j] = '\0';
  }
#+END_SRC

** 3-3

To help out, a test to see whether two characters allow for replacement.

#+BEGIN_SRC C
  int twoAlphOrNum(char a, char b)
  {
    if (('a' <= a && a <= 'z') && ('a' <= b && b <= 'z'))
      return 1;
    else if (('A' <= a && a <= 'Z') && ('A' <= b && b <= 'Z'))
      return 1;
    else if (('0' <= a && a <= '9') && ('0' <= b && a <= '9'))
      return 1;
    return 0;
  }
#+END_SRC

~expand~ works through ~s1~ and when a ~-~ is found tests the characters either side with ~twoAlphOrNum~.
The first and last characters are handled separately in order to ensure it's always safe to test either side of ~-~.

There's a check to ensure something like ~a-a~ is expanded to ~a~, and otherwise a for loop expands everything as required.

We assume ~s2~ is known to have enough space.

~twoAlphOrNum~ can be changed to allow different expansions (e.g. ~0-b~, etc.).

#+BEGIN_SRC C
void expand(char s1[], char s2[])
{
  int s1i = 0;
  int s2i = 0;

  // copy first and last outside of loop
  // length doesn't matter, as at worst this is \0.
  s2[s2i] = s1[s1i];
  ++s1i;
  ++s2i;

  for (int j = strlen(s1) - 1; s1i < j; s1i++) {
    printf("s1i: %d, char: %c\n", s1i, s1[s1i]);
    // know before and after are safe to check
    if (s1[s1i] == '-' && twoAlphOrNum(s1[s1i - 1], s1[s1i + 1])) {
      if (s1[s1i - 1] == s1[s1i + 1]) {
	++s1i;
      } else {
	for (int k = s1[s1i - 1] + 1; k < s1[s1i + 1]; k++, s2i++) {
	  s2[s2i] = k;
	}
      }
    }
    else {
      s2[s2i] = s1[s1i];
      ++s2i;
    }
  }

  s2[s2i] = s1[s1i];
  ++s1i;
  ++s2i;
  s2[s2i] = '\0';
}
#+END_SRC

** 3-4

The problem is there's no way to represent -n when n = -(2^(wordsize-1)).
This is due to 0 being positive.
So, max negative = max positive + 1.

To fix this, we can take the bit complement of a negative number and 'manually' add one.

This results in a special first case, so the do… while… is rewritten to special case… (regular) while…

The special case is just like the regular case expect for negative adjustment is made to record an extra one.
As we still need to be careful of the (bit) size of n, this means ~(n /= 10)~ is repeated in all cases.

#+BEGIN_SRC C
  void itoaPlus(int n, char s[])
  {
    int i, sign;
    if ((sign = n) < 0)
      n = ~n;
    i = 0;

    if (sign < 0) {
      if (n % 10 < 9) {
	s[i++] = n % 10 + '1';
	(n /= 10);
      } else {
	s[i++] = '0';
	(n /= 10);
	++n;
      }
    } else {
      s[i++] = n % 10 + '0';
      (n /= 10);
    }

    while (n > 0) {
      s[i++] = n % 10 + '0';
      (n /= 10);
    }

    if (sign < 0)
      s[i++] = '-';
    s[i] = '\0';
    reverse(s);
  }
#+END_SRC

Note, the initial version had a mistake where ~(n /= 10)~ was part of the while test and a missing ~(n /= 10)~ from the positive first case.
This led to an additional division for negative numbers.

** 3-5

~itob~ is basically the same as ~itoa~.
The only difference is a choice of base and a little more work to figure out the character to print.
The approach taken works so long as the base is less than 37.
I'd need to lookup notation for larger bases.
Though, this should be easy to extend…

Note, given previous observations ~getChar((n % b) + 1)~ is required in the first lookup, as ~getChar((n + 1) % b)~ might make n too large.

#+BEGIN_SRC C
  int getChar(int n)
  {
    if (n < 10) {
      return n + '0';
    } else {
      return (n - 10) + 'a';
    }
  }
#+END_SRC

#+BEGIN_SRC C
  void itob(int n, char s[], int b)
  {
    int i, sign;
    if ((sign = n) < 0)
      n = ~n;
    i = 0;

    if (sign < 0) {
      if ((n % b) < (b - 1)) {
	s[i++] = getChar((n % b) + 1);
	(n /= b);
      } else {
	s[i++] = '0';
	(n /= b);
	++n;
      }
    } else {
      s[i++] = getChar(n % b);
      (n /= b);
    }

    while (n > 0) {
      s[i++] = getChar(n % b);
      (n /= b);
    }

    if (sign < 0)
      s[i++] = '-';
    s[i] = '\0';
    reverse(s);
  }
#+END_SRC

** 3-6

Simple approach is to count down ~w~ whenever a character is added and then add the remaining number of blanks at the end.
~itob~ is modified as ~itoa~ is just a special case.

#+BEGIN_SRC C
  void itobW(int n, char s[], int b, int w)
  {
    int i, sign;
    if ((sign = n) < 0)
      n = ~n;
    i = 0;

    if (sign < 0) {
      if ((n % b) < (b - 1)) {
	s[i++] = getChar((n % b) + 1);
	--w;
	(n /= b);
      } else {
	s[i++] = '0';
	--w;
	(n /= b);
	++n;
      }
    } else {
      s[i++] = getChar(n % b);
      --w;
      (n /= b);
    }

    while (n > 0) {
      s[i++] = getChar(n % b);
      --w;
      (n /= b);
    }

    if (sign < 0) {
      s[i++] = '-';
      --w;
    }
    for (; w > 0; w--, i++) {
      s[i] = ' ';
    }
    s[i] = '\0';
    reverse(s);
  }
#+END_SRC


* chapter 4
** 4-1

To get the right index keep searching through the line and update some variable (here ~lastIndex~) whenever a match is found.

#+BEGIN_SRC C
  int rstrindex(char s[], char t[])
  {
    int i, j, k;
    int lastIndex = -1;

    for (i = 0; s[i] != '\0'; i++) {
      for (j=i, k=0; t[k]!='\0' &s[j]==t[k]; j++, k++)
	;
      if (k > 0 &t[k] == '\0')
	lastIndex = i;
    }
    return lastIndex;
  }
#+END_SRC

** 4-2

Basic idea is to treat any exponentiation as another number.
Use sign to work out whether to up ~val~ or ~power~.

~pw~ is same basic power function from above, renamed as power is already in use.

This could be more elegant.
As, if ~atoi~ took a positional argument the first calculation of ~e~ could be passed off and then used as an exponent on return.


#+BEGIN_SRC C
  double atof(char s[])
  {
    double val, power;
    int i, sign;
    int pluse;
    double e;

    for (i = 0; isspace(s[i]); i++)  /* skip white space */
      ;

    sign = (s[i] == '-') ? -1 : 1;

    if (s[i] == '+' || s[i] == '-')
      i++;

    for (val = 0.0; isdigit(s[i]); i++)
      val = 10.0 * val + (s[i] - '0');

    if (s[i] == '.')
	     i++;

    for (power = 1.0; isdigit(s[i]); i++) {
      val = 10.0 * val + (s[i] - '0');
      power *= 10;
    }

    if (s[i] == 'e' || s[i] == 'E') {
      ++i;
      pluse = (s[i] == '-') ? 0 : 1;
      if (s[i] == '+' || s[i] == '-')
	i++;
      for (e = 0; isdigit(s[i]); i++)
	e = 10 * e + (s[i] - '0');
      e = pw(10, e);
      if (pluse) {
	val *= e;
      } else {
	power *= e;
      }
    }

    return sign * val / power;
  }
#+END_SRC

** 4-3

*** mod

modulus is an additional case.

Here, we do things 'by hand' as ~%~ requires ~int~ args.

#+BEGIN_SRC C
  case '%':
  op2 = pop();
  op1 = pop();
  while (op1 > op2) {
    op1 -= op2;
  }
  push(op1);
  break;
#+END_SRC

An alternative is to downcast the doubles to ints:

#+BEGIN_SRC C
  case '%':
  op2 = pop();
  push(((int) pop() % (int) op2));
  break;
#+END_SRC

*** negative numbers

For negative numbers we only need to make sure any sign is included in the call to ~atoi~.

The following small changes do not work:

#+BEGIN_SRC C
  if (!isdigit(c) && c != '.' && c != '-' && c != '+') /* &&s added */
#+END_SRC

#+BEGIN_SRC C
  if (isdigit(c) || c == '-' || c == '+')    /* ||s added */
#+END_SRC

The issue is + and - are now seen as parts of an number rather than operators.

To fix this, a small check is made at the end of ~getop~ (but after the possible call to ~ungetch~):

#+BEGIN_SRC C
  if (s > 0 && !isdigit(s[i - 1])) {
    return s[i - 1];
  }
#+END_SRC

This checks no integer part was found.
If so, the operator is returned.

With this change we need to ensure ~s~ isn't used for anything else so it's fine to leave the op in ~s~, and it is.

**** fix

The following /works/ but is not right:

#+BEGIN_SRC C
  if (isdigit(c) || c != '-' || c != '+')    /* ||s added */
#+END_SRC

The idea here is we've already recorded the first non-b/t character so we'd like to continue if there's a sign or we have a digit.

~c != '-' || c != '+'~ covers any character, so of course we'll continue…

** 4-4

*** print top

To print the top (two) elements we use '?'.

#+BEGIN_SRC C
  case '?': /* print top two elements, though top is popped if \n is required for input to be processed */
  if (sp == 0)
    printf("The stack is empty\n");
  if (sp > 0)
    printf("Top:\t%g\n", val[sp - 1]);
  if (sp > 1)
    printf("Below:\t%g\n", val[sp - 2]);
  break;
#+END_SRC

These don't do anything fancy to allow inspecting the stack during a calculation.
E.g.:

#+BEGIN_SRC C
1 3 ? + 5 4 * ? +
Top:	3
Below:	1
Top:	20
Below:	4
	24
#+END_SRC

*** duplication

push the top of the stack…

#+BEGIN_SRC C
  case 'd':
  push(val[sp - 1]);
  break;
#+END_SRC

squaring is nice with this (~%n d *~)

*** swap

An interesting desgin choice.
One option is to use ~push~ to store the swap value on the stack.
However, this only works when the stack has space.

A different option is to Gödel encode both numbers to one, swap and then decode.

Or, just use a swap variable…

#+BEGIN_SRC C
  case 's':
  swap = val[sp - 1];
  val[sp - 1] = val[sp - 2];
  val[sp - 2] = swap;
  break;
#+END_SRC

*** clearing

Reset the stack pointer.
There's no need to clean the stack as there's no option to search through the stack.

#+BEGIN_SRC C
  case 'c':
  sp = 0;
  break;
#+END_SRC

** 4-5

This is a puzzling exercise.
Adding library functions is easy (e.g. ~exp~ below).

However, these need to be reduced to a character to be added easily.
Or, better put, things get complex if an attempt is made to use strings to identify operators.

It's easy to convert the core of ~getop~ to a test on whether or not a string represents a number.

The difficulty is dispatch.
This is a switch statement, and switch statements require integers.
So, there are two options:

1. Create an internal character name for each string.
2. Rewrite the dispatch.

Neither option is compelling.
(1) seems very bad pratice, but (2) then requires either:
a. Passing around strings.
b. An external op string seen by all.

An external op string is very much in the spirit of the text.
But, we then /still/ need to work in testing string equality.

This all seems a lot for the Ex.
And, looking at the next ex it seems a switch dispatch is still assumed.

So…

*** exp

#+BEGIN_SRC C
  case 'e':
  push(exp(pop()));
  break;
#+END_SRC

** 4-6

Handling variables is a bit of a headache (may be by design?)

At the global level there's an array to store the variable values and a pointer to the most recently accessed variable.

Every time a variable is seen it is accessed.

Assigning variables is handled by ~n v =~.
Where ~n~ is the value and ~v~ is the variable.

~v~ is evaluated, so the variable pointer is updated, and this can be used to set the value in the variable array to ~n~.

This means variables always have a value.
The could be avoided by setting up a flag for whether a variable has been seen.
But, that would require an additional array.

Varibles are from ~v~ to ~z~ (so five in total).

To the main switch we add:

#+BEGIN_SRC C
  case VARIABLE:
  vp = s[0] - 'v';
  push(vars[vp]);
  break;
#+END_SRC

And:

#+BEGIN_SRC C
  case '=':
  pop(); // ignore variable value
  vars[vp] = pop();
  push(vars[vp]); // evalute var immediately
  break;
#+END_SRC

To ~getop~ we update the ~return c~ check:

#+BEGIN_SRC C
  if (!isdigit(c) && c != '.' && c != '-' && c != '+') {
      if ('v' < c && c <= 'z')
	return VARIABLE;
      else if (c == 'l')
	return LAST;
      return c;      /* not a number */
   }
#+END_SRC

~l~ is a special variable, always set to the most recent pop:

#+BEGIN_SRC C
  double pop(void)
  {
    if (sp > 0) {
      vars[5] = val[--sp];
      return vars[5];
    }
    else {
      printf("error: stack empty\n");
      return 0.0;
    }
  }
#+END_SRC

Note, this doesn't update the variable pointer.

This is all fairly hacky.
And, at the moment it's possible to type in a sequence of varaibles (e.g. ~xvvz~).

This can be fixed, of course.
Though, rewriting ~getop~ and dispatch seem preferable.
In particular, it seems ~getop~ should be broken into getting an expression (delimited by however many spaces) and then testing this to see whether it's a number, variable, op, or special command (print, etc).
Then this can be passed to the relevant dispatch.

Some other time…

** 4-7

The following basically places ~ungetch~ in a loop over the characters in the string.

#+BEGIN_SRC C
  void ungets(char s[])   /* push string back on input */
  {
    for (int i = 0; s[i] != '\0'; i++) {
      if (bufp >= BUFSIZE)
	printf("ungets: too many characters\n");
      else
	buf[bufp++] = s[i];
    }
  }
#+END_SRC

This is roughly the same as:

#+BEGIN_SRC C
  void ungets(char s[])   /* push string back on input */
  {
    for (int i = 0; s[i] != '\0'; i++)
      ungetch(s[i]);
  }
#+END_SRC

The only benift as things stand is a custom error message.

The choice requires more context, I think.

If ~ungets~ should mirror the action of ~ungetch~ then calling ~ungetch~ seems preferable, as any change to ~ungetch~ will pass through to ~ungets~.

Otherwise, leave the parallel coincidental.

One consideration is checking whether the length of the string fits before thinking about ~ungetch~.
One could then avoid partially filling the buffer.

Though, there's no clear motivation to do this, and would amount to more ops.

** 4-8

If there's only one possible character of pushback:

1. Set ~BUFSIZE~ to ~1~.
2. Everything else is optional.

Optionally:

a. The ~bufp~ tests can simply test ~bufp~.
   The pointer is either ~0~ or ~1~.
b. ~bufp~ can be set directly to ~0~ or ~1~.
   For, there's only one possible decrement/increment value.
c. Replace ~buf~ with a single variable.
   ~bufp~ is still used to check whether to use the value of the variable, though.
   (Unless some impossible value for the char is known in advance. So, could use EOF.)

** 4-9

Is the pointer here that EOF is not a character?

So, ~buf~ either needs to allow for ints or some other mechanism needs to be used?

From S1.5.1:

#+BEGIN_QUOTE
This value is called EOF, for "end of file." We must declare c to be a type big enough to hold any value that getchar returns. We can't use char since c must be big enough to hold EOF in addition to any possible char. Therefore we use int.
#+END_QUOTE

This seems the way to go, as ~getchar~ returns ~int~, as def'd in B1.
So, while EOF may be the focus here, the change to ~buf~ ensures anything written to ~buf~ is preserved.

*** the change

#+BEGIN_SRC C
  int buf[BUFSIZE];    /* buffer for ungetch */
#+END_SRC

*** alternative

I don't see a good alternative.

If the goal is to allow EOF pushback, then we'd need some way of storing ~BUFSIZE~ EOFs.

We could also ignore EOFs.
This keep in line with the description of ~getch~ and ~ungetch~ (which originally only mentions characters).

E.g.:

#+BEGIN_SRC C
  void ungetch(int c)   /* push result of getchar back on input */
  {
    if (bufp >= BUFSIZE)
      printf("ungetch: too many characters\n");
    else
      if (c != EOF)
	buf[bufp++] = c;
  }
#+END_SRC

** 4-10

Each line may contain multiple numbers, operators, etc separated by spaces.
So, using ~getline~ requires splitting the line into parts to be processed by ~getop~.

The basic cycle could be:

1. ~main~ calls ~getop~.
2. ~getop~ calls ~gettoken~.
3. ~gettoken~ returns the next token in the string (inlc. EOF).
4. ~getop~ calls ~parsetoken~ which classifies the token and returns to ~main~.

The issue is tokens.
Specifically ~atof~, as this taken a string argumnet.

This requirement suggests ~gettoken~ should copy the token to a string rather than retuning indicies of whether the token begins and ends on the line.

Copying things over seems conceptually the way to go.
For, ~main~ then only needs to know about the next token.

Given how small things are and a desire to keep ~main~ unchanged, the addition of ~gettoken~ and ~parsetoken~ isn't really worth it.

Instead, ~getop~ behaves almost exactly as before, but by walking through the string.

For flexibility, ~getop~ calls either ~getopbystr~ (new) or ~getopbych~ (the old ~getop~):


#+BEGIN_SRC C
  int getop(char s[])
  {
    int getopbystr(char s[]);
    return getopbystr(s);

    /* int getopbych(char s[]); */
    /* return getopbych(s); */
  }
#+END_SRC

The helper function for copying strings is ~copyab~.

#+BEGIN_SRC C
  /* copy: copies 'from' between (inlc.) a and b into 'to'.
     assumes to is big enough */
  void copyab(char to[], char from[], int a, int b)
  {
    int i = 0;

    while (a < b) {
      to[i++] = from[a++];
    }
    to[i] = '\0';
  }
#+END_SRC

~getopbystr~ uses ~getline~ (from the book) and ~copyab~.
The only difference is moving the ~lp~ pointer in contrast to getting a character.

Note, ~line~ and ~lp~ are defined outside ~getopbystr~ to ensure these persist when part of the string is evaluated by ~main~.

#+BEGIN_SRC C
  /* outside of function for persistence */
char line[MAXOP]; /* line buffer */
int lp = 0; /* line pointer, ++lp is unparsed */


int getopbystr(char s[])
{
  int getlinealt(char s[], int lim);
  void copyab(char to[], char from[], int a, int b);

  if (line[lp] == '\0') {
    getlinealt(line, MAXOP);
    lp = 0;
  }

  while (line[lp] == ' ' || line[lp] == '\t')
    lp++; // point smth after b/t

  if (!isdigit(line[lp]) &&
      line[lp] != '.' &&
      line[lp] != '-' &&
      line[lp] != '+') {
    copyab(s, line, lp, lp + 1);
    ++lp;
    if ('v' < line[lp - 1] && line[lp - 1] <= 'z') {
      return VARIABLE;
    }
    else if (line[lp - 1] == 'l') {
      return LAST;
    }
    return line[lp - 1]; /* not a number */
  }

  int i = lp + 1; /* always capture next symbol */

  /* if digit, gather */
  while (isdigit(line[i])) {
    ++i;
  }

  /* collect fraction part if present */
  if (line[i + 1] == '.') {
    ++i;
    while (isdigit(line[i + 1]))
      ++i;
  }

  /* update s
   this could be skipped if not digit, but then need to consider lp update
   and contrast to getopbych */
  copyab(s, line, lp, i);
  /* update unprocessed */
  lp = i;

  if (!isdigit(line[i - 1])) {
    return line[i - 1];
  }
  else {
    return NUMBER;
  }
}
#+END_SRC

The headache here was mapping between original transformations to ~s~ and updates to ~lp~.
The clearest difference is increments to ~i~ (used to extend ~sp~) happen after testing.

Deciding on the behaviour of ~copyab~ (whether inclusive or exclusive wrt. to ~b~) was also a bit of a headache.
Some things work nicely inclusive (getting a single char without incrementing), but others not so much (having ~lp~ point to somethiing inparsed).

** 4-11

If there's only one character saved at a time this can be stored in an ~int~ static variable where some non-char int (e.g. EOF) is used to signal the var hasn't been set.

It's super hard to tell whether the exercise is about ~ungetch~ as written, or the idea of ~ungetch~.

I guess the former as there's no clear alternative without a rewrite.
That is, somehow the issue of reading additional chars needs to be dealt with…

The important thing here is the preceding paragraph.
By using ~static~ variables are in existence regardless of whether or not the function is activated.

So, in short, calls to ~getch~ and ~ungetch~ are inlined, and statics are added for the buffer and associated pointer.
Note, buffersize is a constant as variable statics aren't allowed – storage for a static is only allocated once.

#+BEGIN_SRC C
  /* fill op string by getch and return type info using statics */
int getopbych_static(char s[])
{
  int i, c;
  const int CH_BUFSIZE = 100;
  static int ch_buf[CH_BUFSIZE]; /* buffer for ungetch */
  static int ch_bufp = 0; /* next free position in buf */

  while ((s[0] = c = ((ch_bufp > 0) ? ch_buf[--ch_bufp] : getchar())) == ' ' || c == '\t')
    ;
  s[1] = '\0'; /* what is the purpose of this? s[i] is always set below */

  if (!isdigit(c) && c != '.' && c != '-' && c != '+') {
    if ('v' < c && c <= 'z')
      return VARIABLE;
    else if (c == 'l')
      return LAST;
    return c;      /* not a number */
  }

  i = 0;

  if (isdigit(c) || c == '-' || c == '+')    /* collect integer part */
    while (isdigit(s[++i] = c = ((ch_bufp > 0) ? ch_buf[--ch_bufp] : getchar())))
      ;

  if (c == '.')      /* collect fraction part */
    while (isdigit(s[++i] = c = ((ch_bufp > 0) ? ch_buf[--ch_bufp] : getchar())))
      ;
  s[i] = '\0';

  /* Put char in the buffer */
  if (c != EOF) {
    if (ch_bufp >= CH_BUFSIZE)
    printf("ungetch: too many characters\n");
  else
    ch_buf[ch_bufp++] = c;
  }

  if (i > 0 && !isdigit(s[i - 1])) {
    return s[i - 1];
  }
  return NUMBER;
}
#+END_SRC

** 4-12

Decided to do ~itob~ and to handle negation.

Handling different bases is easy.

Handling negation is difficult, as this requires a special case before recursion can get going.

So, ~itobrecursive~ figures out the sign, and then saves the 'last' char to be appended to ~s~ on return.

#+BEGIN_SRC C
  void itobrecursive(int n, char s[], int b)
  {
    int itobrecursiveHelper(int n, char s[], int b, int sign);

    int sign;
    char saved;

    if ((sign = n) < 0)
      n = ~n;

    if (sign < 0) {
      if ((n % b) < (b - 1)) {
	saved = getChar((n % b) + 1);
      } else {
	saved = '0';
	++n;
      }
    } else {
      saved = getChar(n % b);
    }

    s[itobrecursiveHelper(n / b, s, b, sign)] = saved;
  }
#+END_SRC

~itobrecursiveHelper~ carries sign as this is to be written first.
The /only/ neat thing here is returning the position to write the next character in ~s~.
~sign~ can then be used to store this as it's used to write a char and as the base for the return val.

#+BEGIN_SRC C
  int itobrecursiveHelper(int n, char s[], int b, int sign)
  {
    if (n == 0) {
      if (sign < 0) {
	s[0] = '-';
	return 1;
      } else {
	return 0;
      }
    }
    else if (n > 0) {
      sign = itobrecursiveHelper((n / b), s, b, sign);
      s[sign] = getChar(n % b);
      return sign + 1;
    } else {
      return EOF; /* to ensure a return */
    }
  }
#+END_SRC

** 4-13

Here's a simple reverse that temporarily stores each int in the array and then writes everything back in reverse order, using basically the same idea from ~itobrecursive~:

#+BEGIN_SRC C
  void rreverse(char s[])
  {
    int rreversehelper(char s[], int i);
    rreversehelper(s, 0);
  }

  int rreversehelper(char s[], int i)
  {
    if (s[i] == '\0') {
      return 0;
    } else {
      int store = s[i];
      i = rreversehelper(s, ++i);
      s[i] = store;
      return ++i;
    }
  }
#+END_SRC

This is very simple to set up.
However, improvements can be made.
For example, you could first calculate the length of ~s~.
With this in hand, pass a ~dist~ arg to the helper and use this to find the opposing element as you work through the first half of the array (~dist -= 2~ each time).
Then, start ~i~ at half the length.
And, if possible cancel the return.
This then cuts down on space and time should be about the same (as the lack of return compensates for the initial length task, if any).

** 4-14

This is very neat.

#+BEGIN_SRC C
  #define swp(t,x,y) { t swap = x; x = y; y = swap; }
#+END_SRC

Though, this isn't ideal if there's a possibiliy ~x~ or ~y~ is called ~swap~.

Something like:

#+BEGIN_SRC C
  #define swp(t,x,y) { t a = x; t b = y; t swap = a; a = b; b = swap; x = a; y = b; }
#+END_SRC

Is of no help either, though I'm not sure why.
Expanded, ~swp(t,a,b)~ should be:

#+BEGIN_SRC C
  {
    t a = a;
    t b = b;
    t swap = a;
    a = b;
    b = swap;
    a = a;
    b = b;
  }
#+END_SRC

So, one would think equivalent to:

#+BEGIN_SRC C
  {
    t swap = a;
    a = b;
    b = swap;
  }
#+END_SRC

But, this isn't the case, and a swap doesn't happen .

Nor does using ~swp~ as the name of the interal var help, as no warining are given regarding the macro/var ambiguity.

So, macros seems volatile…


* chapter 5
** 5-1

The change is to add an additional int ~d~ so one steap ahead can be checked.

I tripped up here on failing to realise the importance of updating ~c~ to ~d~ for a while.

#+BEGIN_SRC C
  /* getint: get next integer from input into *pn */
  int getint(int *pn)
  {
    int c, d, sign;

    while (isspace(c = getch())) /* skip white space */
      ;

    if (!isdigit(c) && c != EOF && c != '+' && c != '-') {
      ungetch(c); /* it is not a number */
      return 0;
    }

    sign = (c == '-') ? -1 : 1;

    if (c == '+' || c == '-') {
      d = getch();
      if (!isdigit(d)) {
	if (d != EOF) {
	  ungetch(d); /* wait to see what comes next */
	}
	ungetch(c); /* not an int, return sign */
	return c;
      }
      else {
	c = d; /* d is the next c */
      }
    }

    for (*pn = 0; isdigit(c); c = getch())
      ,*pn = 10 * *pn + (c - '0');
    ,*pn *= sign;

    if (c != EOF)
      ungetch(c);
    return c;
  }
#+END_SRC

** 5-2

Reminiscent of exercises from ch. 4.

Look for a dot any continue to accumulate, this time dividing the char/int by increasing powers of ten.

The return type remains ~int~ as this is only used to return a non-usable char.
The float itself is stored at ~*pn~.

#+BEGIN_SRC C
  int getfloat(float *pn)
  {
    int c, d, sign;
    float power(int n, int m);

    while (isspace(c = getch())) /* skip white space */
      ;

    if (!isdigit(c) && c != EOF && c != '+' && c != '-') {
      ungetch(c); /* it is not a number */
      return 0;
    }

    sign = (c == '-') ? -1 : 1;

    if (c == '+' || c == '-') {
      d = getch();
      if (!isdigit(d)) {
	if (d != EOF) {
	  ungetch(d); /* wait to see what comes next */
	}
	ungetch(c); /* not an int, return sign */
	return c;
      }
      else {
	c = d; /* d is the next c */
      }
    }

    for (*pn = 0; isdigit(c); c = getch())
      *pn = 10 * *pn + (c - '0');

    if (c == '.') {
      c = getch();
      int dec = 1;
      for (; isdigit(c); c = getch()) {
	*pn = (*pn + ((float) (c - '0') / power(10, dec)));
	++dec;
      }
    }

    *pn *= sign;

    if (c != EOF)
      ungetch(c);
    return c;
  }
#+END_SRC

** 5-3

A direct modification of ~strcat_book~.

The contrasting ~while~ loops are kind of interesting.

For the first we want ~*s~ to point to the end of ~s~, before ~\0~.
So, incrementing ~s~ happens only after the test is passed.

For the second, it doesn't matter where ~*s~ or ~*t~ point to when everything is over and it is important ~\0~ is copied over.
So, the test is Incorporated into the loop.

#+BEGIN_SRC C
  void strcat_ptr(char *s, char *t)
  {
    while (*s != '\0') /* find the end of s */
      s++;

    while ((*s++ = *t++) != '\0') /* copy t */
      ;
  }
#+END_SRC

** 5-4

The idea is to go to the end of ~s~ and ~t~ and then work backwards.

The length of ~s~ and ~t~ is stored as this is used to place a limit on how far back to go (there's no unique initial char).

If ~t~ is at the end of ~s~ then ~tlen~ will be ~-1~ due to ~tlen~ being decremented on each character match and the need to test the initial (~0~) character.

#+BEGIN_SRC C
  int strend(char *s, char *t)
  {
    int slen = 0;
    int tlen = 0;

    while (*s != '\0') { /* find the end of s */
      s++;
      slen++;
    }

    while (*t != '\0') { /* find the end of s */
      t++;
      tlen++;
    }

    while (*s == *t && tlen >= 0 && slen >= 0) {
      s--;
      t--;
      slen--;
      tlen--;
    }

    if (tlen == -1) {
      return 1;
    } else {
      return 0;
    }
  }

#+END_SRC

** 5-5

*** strncpy

Straightforward modification of ~strcpy~.

It's not clear to me whether the test remains important, or whether ~\0~ is defined to be ~0~.

#+BEGIN_SRC C
  /* copy at most n chars of t to s */
  void strncpy_ptr(char *s, char *t, int n)
  {
    while ((*s++ = *t++) != '\0' && --n > 0)
      ;
  }
#+END_SRC

*** strncat

Same as ~strncat~ from before, but with the same copy as ~s~.

#+BEGIN_SRC C
  /* concatenate n chars of t to end of s  */
  void strncat_ptr(char *s, char *t, int n)
  {
    while (*s != '\0') /* find the end of s */
      s++;

    while ((*s++ = *t++) != '\0' && --n > 0) /* copy n of t */
      ;
  }
#+END_SRC

The following should work equally well:

#+BEGIN_SRC C
  void strncat_ptr(char *s, char *t, int n)
  {
    while (*s != '\0')
      s++;

    strncpy_ptr(s, t, n);
  }
#+END_SRC

*** strncmp

The same mod…

#+BEGIN_SRC C
  int strncmp_ptr(char *s, char *t, int n)
  {
    for ( ; *s == *t && --n > 0; s++, t++)
      if (*s == '\0')
	return 0;
    return *s - *t;
  }
#+END_SRC

** 5-6

I'll pass on most of the options for now.

The issue is none of this seems enlightening.

I picked ~reverse~ thinking this might be an interesting case, but here's a minimal change:

#+BEGIN_SRC C
  void reverse_ptr(char *s)
  {
    int c, i, j;

    for (i = 0, j = strlen(s)-1; i < j; i++, j--) {
      c = s[i];
      s[i] = s[j];
      s[j] = c;
    }
  }
#+END_SRC

Given the relation between pointers and arrays, nothing really needs to be altered other than the argument.

Indeed, given the way swap happens there's really no interest in doing anything else.

At best, it might be useful to keep the deref notation throughout the function, like:

#+BEGIN_SRC C
  void reverse_ptr(char *s)
  {
    int c, i, j;

    for (i = 0, j = strlen(s)-1; i < j; i++, j--) {
      c = *(s + i);
      *(s + i) = *(s + j);
      *(s + j) = c;
    }
  }
#+END_SRC

** 5-7

~ALLOCSIZE~ is defined outside of any func, similar to ~alloc~.
This is so both ~main~ and ~readlines~ can see the size of the buffer allocated for storing lines.

Inside ~main~ a ~char~ array ~buf~ is created parallel to ~allocbuf~.

~readlines~ is then modified to take ~buf~ as an argument.

There's no interaction with ~buf~ outside of ~readlines~.
So, ~bufp~, the counterpart to ~allocp~ can be kept internal to ~readlines~.

The rest is commented:

#+BEGIN_SRC C
  int readlines_main(char *lineptr[], int maxlines, char buf[])
  {
    int getlinealt(char *, int);

    char *bufp = buf; /* buf only updated within readlines */
    int len;
    char line[MAXLEN];
    int nlines = 0;

   while ((len = getlinealt(line, MAXLEN)) > 0)
     /* replicate free mem test inline */
     if (nlines >= maxlines || (buf + ALLOCSIZE - bufp < len))
       return -1;
     else {
       line[len - 1] = '\0'; /* delete newline */
       strcpy(bufp, line);
       lineptr[nlines++] = bufp; /* store ptr to line */
       bufp += len; /* update bufp past stored line */
     }
   return nlines;
  }
#+END_SRC

Note, it's important to update ~bufp~ only after ~bufp~ when pointing to the start of the line has been stored.

So, the only alternative to the above is:

#+BEGIN_SRC C
  int readlines_main(char *lineptr[], int maxlines, char buf[])
  {
    int getlinealt(char *, int);

    char *bufp = buf; /* buf only updated within readlines */
    int len;
    char line[MAXLEN];
    int nlines = 0;

   while ((len = getlinealt(line, MAXLEN)) > 0)
     /* replicate free mem test inline */
     if (nlines >= maxlines || (buf + ALLOCSIZE - bufp < len))
       return -1;
     else {
       line[len - 1] = '\0'; /* delete newline */
       lineptr[nlines++] = bufp; /* store ptr to line */
       strcpy(bufp, line);
       bufp += len; /* update bufp past stored line */
     }
   return nlines;
  }
#+END_SRC

Though, this alternative raise the possibility of ~strcpy~ returning an incremented ~bufp~.

** 5-8

For both functions ~-1~ is used to indicate an error, as any error free value must be positive.

~day_of_year~ first checks the month is possible as this does not require figuring out whether it's a leap year.

Then, when whether the year is a leap year has been figured out a check on whether the day is a possible day given the month is checked.

#+BEGIN_SRC C
  int day_of_year(int year, int month, int day)
  {
    int i, leap;
    if (month < 1 || 12 < month)
      return -1;

    leap = year%4 == 0 &year%100 != 0 || year%400 == 0;

    if (day < 1 || daytab[leap][month] < day)
      return -1;

    for (i = 1; i < month; i++)
      day += daytab[leap][i];
    return day;
  }
#+END_SRC

~month_day~ figures out whether the year is a possible leap year and then checks whether the total number of days is possible.

As ~month_day~ doesn't have a return value the error is written to ~*pmonth~ and ~*pday~.
Though, strictly only one of these needs to be set.

#+BEGIN_SRC C
  void month_day(int year, int yearday, int *pmonth, int *pday)
  {
    int i, leap;

    leap = year%4 == 0 &year%100 != 0 || year%400 == 0;

    if ((leap && yearday > 366) || (!leap && yearday > 365)) {
      *pmonth = -1;
      *pday = -1;
    } else {
      for (i = 1; yearday > daytab[leap][i]; i++)
	yearday -= daytab[leap][i];
      *pmonth = i;
      *pday = yearday;
    }
  }
#+END_SRC

** 5-9

Fairly straightforward.
The pattern is ~a[i]~ to ~*(a + i)~.
So, ~a[i][j]~ -> ~(*(a + i))[j]~ -> ~*((*(a + i)) + j)~ = ~*(*(a + i) + j)~.

With this in hand we have:

#+BEGIN_SRC C
  int day_of_year_ptr(int year, int month, int day)
  {
    int i, leap;
    if (month < 1 || 12 < month)
      return -1;

    leap = year%4 == 0 &year%100 != 0 || year%400 == 0;

    if (day < 1 || *(*(daytab + leap) + month) < day)
      return -1;

    for (i = 1; i < month; i++)
      day += *(*(daytab + leap) + i);
    return day;
  }
#+END_SRC

And:

#+BEGIN_SRC C
  void month_day_ptr(int year, int yearday, int *pmonth, int *pday)
  {
    int i, leap;

    leap = year%4 == 0 &year%100 != 0 || year%400 == 0;

    if ((leap && yearday > 366) || (!leap && yearday > 365)) {
      *pmonth = -1;
      *pday = -1;
    } else {
      for (i = 1; yearday > *(*(daytab +leap) + i); i++)
	yearday -= *(*(daytab +leap) + i);
      *pmonth = i;
      *pday = yearday;
    }
  }
#+END_SRC

** 5-10

At a high level, this is the calculator from before but revised to take arguments over reading from a string.

In a little more detail, working with commands makes this a fair bit easier as there's no need to divide a string/input into distinct arguments.

This allows the core loop to be cleaned up a little.

~main~ is now:

#+BEGIN_SRC C
  int main(int argc, char *argv[])
  {
    void evaluate(int type, char s[]);

    ++argv;
    while (--argc > 0) {
      evaluate(parseop(*argv), *argv);
      ++argv;
    }

    return 0;
  }
#+END_SRC

In short, so long as there's an argument to work with parse the argument and then evaluate the argument given the parse.

~parseop~ figures out whether the arg is a variable or number.
I.e. it's the same as ~getop~ without worrying about dividing a string:

#+BEGIN_SRC C
  int parseop(char *arg)
  {
    int i = 0;

    if (!isdigit(arg[i]) && arg[i] != '.' && arg[i] != '-' && arg[i] != '+') {
      if ('v' < arg[i] && arg[i] <= 'z')
	return VARIABLE;
      else if (arg[i] == 'l')
	return LAST;
      return arg[i];      /* not a number */
    }

    if (isdigit(arg[i]) || arg[i] == '-' || arg[i] == '+')
      while (isdigit(arg[++i]))
	;
    if (arg[i] == '.')      /* collect fraction part */
      while (isdigit(arg[++i]))
	;

    if (i > 0 && !isdigit(arg[i - 1]))
      return arg[i - 1];
    else if (arg[i] == '\0') // only return n if exhausted arg
      return NUMBER;
    else
      return 0;
  }
#+END_SRC

The slight change is a check on whether there's arg is a digit by checking to see there's no additional chars in the arg after digits have been exhausted.

~evaluate~ is the switch previously in ~main~.
There are two differences.

First, the variable case no longer returns the value of the variable.
This means you can silently assign a variable.

#+BEGIN_SRC C
  case VARIABLE:
  vp = s[0] - 'v';
  // printf("variable vp: %d\n", vp);
  push(vars[vp]);
  break;
#+END_SRC

Second, newlines are no longer relevant, so printing happens by typing 'p'.

#+BEGIN_SRC C
  case 'p':
    printf("\t%.8g\n", pop());
    break;
#+END_SRC

At this point, revising ~evaluate~ to work on strings would be nice to allow for more expressive arguments…

** 5-12

No super confident on stops but with some minor adjustments at worst this should be good.

The idea is to save an array of integers used to determine the length of a stop.
This is then cycled through.

The stop list is an string argument of space separated ints.

The func ~satoia~ uses library funcs ~isdigit~ and ~atoi~ to create a parallel list of integers.

#+BEGIN_SRC C
/* reads a arr of ints separated by a (single) space to an array
   up to specified max and returns number of ints found. */
int satoia(char *in, int *out, int max)
{
  int foundints = 1;
  while (*in != '\0' && max > 0) {
    if (*in == ' ') {
      ++out;
      ++foundints;
    }
    else if (isdigit(*in)) {
      *out = atoi(in);
      --max;
      while (isdigit(*(in + 1))) // atoi captures int
	in++;                    // so skip chars
    }
    else {
      return -1;
    }
    in++;
  }
  *++out = '\0';
  return foundints;
}
#+END_SRC

~main~ then checks the list is legal and otherwise defaults to the list ~"4"~.

#+BEGIN_SRC C
int main(int argc, char *argv[])
{
  int satoia(char *in, int *out, int max);

  stops = satoia(argv[1], &stopdist[0], MAX_STOPS);

  if (stops < 1) {
    stops = satoia("4", &stopdist[0], MAX_STOPS);
  }

  // detab();
  entab();

  return 0;
}

#+END_SRC

*** entab

~entab~ is rewritten from before though the core idea remains the same.
spaces are ignored unless needed and a check is made to see whether a tab should be inserted.

As stops are variable, a for loop simulates a tab by printing an equal number of the current stop as an int.
This obv. doesn't work if the stop is greater than 9.

Note, the stops given are cycled through.
This could be changed to stay at the last stop, etc.

#+BEGIN_SRC C
  void entab(void)
  {
    int stopp = 0;
    int spacesSeen = 0;
    int afterTab = 0;
    char c;

    while ((c = getchar()) != EOF) {

      ++afterTab;

      if (c == '\n') { // reset on newline
	stopp = 0;
	spacesSeen = 0;
	afterTab = 0;
      }

      if (c == ' ') { // if space then maybe replace with tab
	++spacesSeen;
      }
      else { // char, so first
	while (spacesSeen > 0) { // insert spaces skipped over in hope of tab
	  putchar(' ');
	  --spacesSeen;
	}
	putchar(c); // insert char
      }

      if (afterTab == stopdist[stopp]) { // check to see if at stop
	if (spacesSeen) {
	  for (int a = 0; a < spacesSeen; a++) putchar('0' + stopdist[stopp]);
	  // putchar('\t');
	  spacesSeen = 0;
	}
	afterTab = 0;
	stopp = (stopp + 1) % stops;
      }
    }
  }
#+END_SRC




** 5-13
*** tail

The basic idea is to use a looping buffer/array of string pointers.
As we store the last n strings, storage for the next string is either already free or obtained by deleting the 'next' string in the buffer.

This is perhaps clearest seen when calculating space:

#+BEGIN_SRC C
    int allocbuf_space(char *line_a, char *line_b)
  {
    if (*line_b == allocbuf[ALLOCSIZE - 1]) {
      // haven't looped around, so whatever's left after line_a of buffer.
      return (&allocbuf[ALLOCSIZE - 1] - line_a);
    }
    else if ((line_b + 0) >= line_a) {
      // line_b does not require a loop, so space until line_b starts
      return (line_b + 0) - line_a;
    }
    else {
      // line_b requires a loop, so take everything used until line_a
      // and flip
      return ALLOCSIZE - (line_a - (line_b + 0));
    }
  }
#+END_SRC

Aside:
The first version confused the value of a pointer with the pointer.
This slipped through (initial) testing as I only used single characters.

line b is always the line after line a when called.
So, this returns the space until line b starts.

Likewise, obtaining the next space to store a char loops:

#+BEGIN_SRC C
  char *next_allocbuf(char *current_allocbuf)
  {
    if ((current_allocbuf - allocbuf) == (ALLOCSIZE - 1)) {
      return &allocbuf[0];
    }
    else {
      return current_allocbuf + 1;
    }
  }
#+END_SRC

Pretty much everything happens in main as there's no way to store a variable sized buffer outside of a function (at least given the tools presented so far).

#+BEGIN_SRC C
#define ALLOCSIZE 1023
static char allocbuf[ALLOCSIZE + 1];

int main(int argc, char *argv[])
{
  void read_args(int argc, char *argv[], int *n);
  int allocbuf_space(char *line_a, char *line_b);
  char *next_allocbuf(char *current_allocbuf);

  int line_ptrs = 5; // default number of line pointers

  read_args(argc, argv, &line_ptrs); // read arguments

  char *line_ptr_buf[line_ptrs]; // buffer for line pointers
  int lp_i = 0; // first run immediately sets to +1 i.e. 0
  char new_str = 1; // boolean for whether to store a new string

  for (int i = 0; i < line_ptrs; i++)
    line_ptr_buf[i] = &allocbuf[ALLOCSIZE];

  /* main loop.
     while c (char) isn't EOF
     if c is newline, update buffer stuff.
     else, so long as space then add to buffer.
  */

  printf("Line pointers = %d\n", line_ptrs);

  char c;
  int available_space = ALLOCSIZE;
  char *allocbuf_ptr = &allocbuf[0] - 1; // points to next available space

  while ((c = getchar()) != EOF) {
    if (new_str) { // take care of new string if needed
      // move allocbuf_ptr and lp_i forward
      allocbuf_ptr = next_allocbuf(allocbuf_ptr);
      lp_i = ((lp_i + 1) % line_ptrs);
      // update new line
      line_ptr_buf[lp_i] = allocbuf_ptr;
      // space is from deleting next pointer.
      available_space = allocbuf_space(line_ptr_buf[lp_i],
				       line_ptr_buf[(lp_i + 1) % line_ptrs]);
      new_str = 0;
    }

    if (c == '\n') {
      *allocbuf_ptr = '\0'; // end the string
      new_str = 1; // set new string on next char
    }
    else if (available_space > 2) { // store the char, ptr forward, reduce space.
	*allocbuf_ptr = c;
	allocbuf_ptr = next_allocbuf(allocbuf_ptr);
	--available_space;
    }
    else {
      printf("Ah, out of space!: %c\n", c);
    }
  }

  /* to print the buffer
  printf("------\n");
  for (int j = 0; j < ALLOCSIZE; j++)
    printf("%d: %c\n", j, allocbuf[j]);
  printf("------\n");
  */

  for (int j = 0; j < line_ptrs; j++) {
    int offset = (lp_i + j + 1) % line_ptrs;
    if (line_ptr_buf[offset] != &allocbuf[ALLOCSIZE]) {
      // printf("%d: ", j); // display lines
      for (char *k = line_ptr_buf[offset]; *k != '\0'; k++) {
	printf("%c", *k);
    }
    printf("\n");
  }
  }
  return 0;
}
#+END_SRC

Two things of note:

1. ALLOCSIZE reserves an extra space for testing whether a line pointer has been used.
   An alternative is to have a counter of something, but this seems clean enough.
2. Setting up for a new string happens on the next character after a new line.
   This is so any line stored in the buffer is not overwritten if an EOF immediately follows a new line.
   There are various other ways to deal with this, but it seems conceptually easiest to only write when needed.
3. (1) simplifies printing the lines.
   For, it's possible to print everything starting from the next pointer (looping around).
   And, any pointer that's unused is easily filtered out.
   The alternative requires different approaches depending on whether the line buffer has been filled (need to start one ahead) or not (start with the current pointer).
   I'm not sure if there's an elegant solution here.

The main thinking point with this exercise was what to do with the line pointer buffer.
There's not really a good option other than storing everything in main.
And, this itself is not ideal as it clutters main with details.
Still, this seems the only way to go, as no other storage persists between function calls.

Though, after thinking things through the main thinking points ended up being caution regarding values of pointers and pointers, and what to do with mod.

Working out a better solution for a full buffer is for some other time.
At the moment additional characters are ignored, and cycling through the buffer is needed to clear it.
Alternatively one could eat previous lines as needed, and trigger something if the current line is too big for the buffer.

Likewise, the approach to printing lines may not be ideal if the lines allowed are large but only a small number are typically stored.

Anyway, some other time…

*** misread - last n chars

Misread this to be about the last /n/ characters.
And, an earlier function written for interest fits well for this purpose.

~whu~ walks through a string storing the last ~n~ chars in an array.

#+BEGIN_SRC C
  /* func to test a pointer arithmetic idea
   basically, this stores the last n chars of from in to
   and returns the index of where to start reading to from
   in order to reconstruct */
  int whu(char *from, char *to, int n)
  {
    int i = 0;
    while (*from != '\0') {
      (*(to + (i++ % n)) = *from);
      from++;
    }
    *(to + i++) = '\0';
    if (i > n)
      return i % n;
    else
      return 0;
  }

#+END_SRC

As the characters are stored using ~mod~, reconstruction requires starting from ~i~ and returning to the start of the array when required.

~tail~ is fragile as written, and assumes after ~-n~ is a number.
~atoi~ is from ~stdlib~.

After (maybe) updating ~n~ the last ~n~ digits of the string given as an argument are recovered.

#+BEGIN_SRC C
  int tail(int argc, char *argv[])
  {
    int c;
    int n = 10;

    while (--argc > 0 && (*++argv)[0] == '-') {
      c = *++argv[0]; /* just check the first char after - */
      switch (c) {
      case 'n':
	n = atoi(*++argv) + 1; /* next arg specifies number */
	--argc;
	break;
      default:
	printf("illegal option %c\n", c);
	break;
      }
    }

    char to[n];
    int whu(char *from, char *to, int n);

    int i = whu(argv[0], to, n);

    for (int j = i; j < (i + n - 1) && to[j % n] != '\0'; j++) {
      printf("%c", to[j % n]);
    }
    printf("\n");

    return 0;
  }
#+END_SRC

** 5-14

The flag follows the template set out for ~flag~.

So, the only thing to think about is reversing the result.

There are two options:

1. Require the comparison operators to take a reverse argument.
2. Reverse the result after comparison is over.

The latter is very simple to do, as it amounts to walking backwards through the sorted array.
And, as the length is known, this is about as taxing as walking forwards:

#+BEGIN_SRC C
  /* writelines_reverse: write output lines in reverse */
  void writelines_reverse(char *lineptr[], int nlines)
  {
    lineptr = lineptr + (nlines - 1); // jump to end
    while (nlines-- > 0) // print going backwards
      printf("%s\n", *lineptr--);
  }
#+END_SRC

** 5-15

*** initial

Again, issues of abstraction.
Do we extend ~str_cmp~ to take an additional argument?
If so, this requires a rewrite of ~str_cmp~.

So, here's a parallel function, which uses ~lower~ to lowercase any alphabetic character.

#+BEGIN_SRC C
char lower(char c)
{
  if ('A' <= c && c <= 'Z')
    return c - 'A' + 'a';
  else
    return c;
}
#+END_SRC

#+BEGIN_SRC C
int strcmp_bk_fold(char *s, char *t)
{
  char lower(char c);
  for ( ; lower(*s) == lower(*t); s++, t++)
    if (*s == '\0')
      return 0;
  return lower(*s) - lower(*t);
}

#+END_SRC

Then, there's an issue of choosing between the sorting functions.

As there's no way (I have found) to set up a function variable (unless writing ~void x~, which seems inadvisable) it seems easiest to split calls to ~qsort~ into cases:

#+BEGIN_SRC C
  if ((nlines = readlines(lineptr, MAXLINES)) >= 0) {
  if (numeric) {
    qsort_bk((void**) lineptr,
	     0,
	     nlines - 1,
	     (int (*)(void*,void*)) numcmp_bk);
  }
  else if (fold) {
    qsort_bk((void**) lineptr,
	     0,
	     nlines - 1,
	     (int (*)(void*,void*)) strcmp_bk_fold);
  }
  else {
    qsort_bk((void**) lineptr,
	     0,
	     nlines - 1,
	     (int (*)(void*,void*)) strcmp_bk);
  }
#+END_SRC

Though, with this passing additional parameters to any given sorting function is simple.
On the other hand, it might be hard to see where an argument flag goes.
Hum hum.

*** second pass

With directory order intended to work with fold it seems there should be a single string sorting function.

Though, as this can't take additional arguments, it relies on the relevant flags being set outside of ~main~.

~fold~ is an optional conversion, so ~fold ? lower(*s) : *s~ is natural.
However, in-lining this test gets messy.
So, an opportunity to use ~do… while…~!
This is important as we want to (maybe) convert to lowercase before equality is checked.
An additional pair of variables is needed as the (maybe) conversion needs to be stored.
And, helpfully, this means ~s~ and ~t~ can be incremented immediately.

#+BEGIN_SRC C
  int strcmp_fold(char *s, char *t)
  {
    char lower(char c);
    char a, b;

    do {
      a = fold ? lower(*s) : *s; // set a and b for comp
      b = fold ? lower(*t) : *t;

      if (a == b && a == '\0') // check exit
	{ return 0; }

      ++s; // update s and t for next cycle
      ++t;
    }
    while (a == b);
    return a - b;
  }
#+END_SRC

** 5-16

With the updated ~strcmp_fold~ adding directory order is simple.

First, a helper function to check whether a character is a letter, number, or blank:

#+BEGIN_SRC C
  char isLNB(char *c)
  {
    return (('A' <= *c && *c <= 'Z') ||
	    ('a' <= *c && *c <= 'z') ||
	    ('0' <= *c && *c <= '9') ||
	    *c == ' ');
  }
#+END_SRC

Then, skip anything which doesn't satisfy the above test (and don't go past the bounds of the string).

#+BEGIN_SRC C
  int strcmp_fold(char *s, char *t)
{
  char isLNB(char *c);
  char lower(char c);
  char a, b;

  do {

    if (directory) {
      while (!isLNB(s) && *s != '\0')
	{ ++s; }
      while (!isLNB(t) && *t != '\0')
	{ ++t; }
    }

    a = fold ? lower(*s) : *s;
    b = fold ? lower(*t) : *t;

    if (a == b && a == '\0')
      { return 0; }

    ++s;
    ++t;
  }
  while (a == b);
  return a - b;
}
#+END_SRC

** 5-17

So, I guess the idea is to sort on substrings identified somehow.
For a general approach, it may be preferable to work with start/end indicies.
This won't work for variable fields, but a different program could first figure out which indicies the field corresponds to.

But where to do this?
I guess as arguments to the comparison function inside quicksort.
So, the idea is:

1. Before the comparison save pointers to the start of each string.
2. Update pointers to be passed to start index, or the end of string (whichever is first).
3. Walk through each string until one past the end index or the end of string.
4. Save the character and temporarily replace with end of string.
5. Do the comparison.
6. Replace the stored character (if any).

Or, alternatively, copy each substring to temporary buffers and do the comparison on the substrings.

There are another two alternatives.

a. Store two arrays.
   The first is substring and the second is full strings.
   At the end of the first is a pointer to the second.
   Sorting happens on the first, but on print the pointer is followed to the second.
b. Modify the comparison functions.

Ah, okay, modifying the comparison seems nice.
For, rather than passing functions to quicksort directly these can first be passed to an 'update strings' function which deals with any transformation to the strings and then switches to a particular comparison function.
I.e. this function could do all the steps outlined above.

This seems the best option.

** TODO 5-18
** TODO 5-19
** TODO 5-20

* chapter 6

** 6-1

Without some examples I'm not entirely sure what was intended.
In any case…

~iswordpart~ expands what is allowed as a word part.
Here, various symbols are included.

By 'a more general getword than is necessary for this program' I guess the authors mean there's really no need to check the initial character, as a word is only relevant if matched to something in keytab.
In any case, to keep the original distinction an argument is passed depending on whether or not one is checked the start of a word.

#+BEGIN_SRC C
int iswordpart(int c, int initialchar)
{
  return ((initialchar ? isalpha(c) : isalnum(c)) ||
	  c == '_' ||
	  c == '/' ||
	  c == '*' ||
	  c == '#');
}
#+END_SRC

Both '_' and '#' are (maybe) used for keywords.
E.g. ~__LINE__~ or ~#define~.
~/~ and ~*~ enable checking for a comment.

To deal with string constants and commends we reconfigure the while loop to skip anything between escape strings (e.g. ~/*~ or ~"~).

The loop is now:

#+BEGIN_SRC C
  while (getword(word, MAXWORD) != EOF) {
    // skip anything between comments
    if (checkleftescape(word))
      { while ((gw = getword(word, MAXWORD)) != EOF && !checkrightescape(word)) { }; }
    // note additional EOF check
    if (gw != EOF && (n = binsearch(word, keytab, NKEYS)) >= 0)
      { keytab[n].count++; }
  }
#+END_SRC

The idea of ~checkleftescape~ and ~checkrightescape~ is to check whether an escape string is found and then skip or stop skipping.

These are defined using ~strcmp~, and when an escape string is found the /opposing/ string is stored and tested for:

#+BEGIN_SRC C
  /* if escape string is found write down closing string
     note, strcmp returns 0 when strings are equal. */
  char esc_str[3];

  int checkleftescape(char *word)
  {
    if (!strcmp(word, "/*"))
      { strcpy(esc_str, "*/");
	return 1; }
    else if (!strcmp(word, "\""))
      { strcpy(esc_str, word);
	return 1; }
    else if (!strcmp(word, "//"))
      { strcpy(esc_str, "\n");
	return 1; }
    else
      { return 0; }
  }

  int checkrightescape(char *word)
  {
    return !strcmp(word, esc_str);
  }
#+END_SRC

Note, ~esc_str~ should be expanded if longer escape strings are added.

I think this is sufficient for now.
The extension to calls to ~isalpha~ and ~isalnum~ just means additional searches are made.
And, perhaps the easiest thing to do here is to signal whether a non-keyword character was seen and hold this signal until the search happens.

** TODO 6-2

Deferred until after in/out is covered

** TODO 6-3

Deferred until after in/out is covered

** TODO 6-4

** 6-5

(Initial sketch without testing anything.)

Suppose There are two cases for deletion.
Either:

1. We're at the start of the list and need to update the hashtab pointer.
2. We're part way through the list and need to update an ~nlist~ pointer.

We use a ~toDelete~ variable to unify freeing memory and returning a value.

Start by storing the hash and setting ~np~.

If ~np~ is ~NULL~ everything falls through.

Otherwise, if ~np~ is not  ~NULL~ check the name and set ~np~ for deletion if match and point the hash table entry to whatever is next in the list.

If ~np~ is not ~NULL~ and a match hasn't been found work through the list, checking the name of the /next/ element (so long as not ~NULL~).

The only thing I'm not sure about here is the use of ~free~.
Does ~free~ recursively apply to all objects pointed to by the structure, or are the handled separately?

#+BEGIN_SRC C
  /* undef: remove s in hashtab */
  int *undef(char *s)
  {
    unsigned hash(char *s);

    unsigned h = hash(s);
    struct nlist *np = hashtab[h];
    struct nlist *toDelete;

    if (np != NULL && strcmp(s,np->name) == 0)
      { toDelete = np;
	hashtab[h] = np->next; }

    for ( ; np != NULL; np = np->next)
      if (np->next != NULL && (strcmp(s, np->next->name) == 0))
	{ toDelete = np;
	  np->next = toDelete->next;
	}

    if (toDelete != NULL)
      { // free(toDelete->name);
	// free(toDelete->defn);
	free(toDelete);
	return 1; } /* undefed */
    else
      return 0; /* not found */
  }
#+END_SRC
